#!/bin/bash

#----------------------------------------------------------------------------------------------
function deploy.usage()
{
    local -i exit_status=${1:-1}
    local -r progname="$( basename "${BASH_SOURCE[0]}" )"

    cat >&2 << EOF
Usage:
    $progname [ -h|--help ]
              | [ --clean ]
              | [ --down ]
              | [ --init ]
              | [ --latest ]
              | [ --promote <branch> ]
              | [ --tag <image_tag> ]

    Common options:
        -h --help              Display a basic set of usage instructions
        -c --clean             0:do not clean environment
                               1:clean environment before build (default)
        -d --down              stop services defined by 'docker-compose.yml'
        -i --init              only initialize the environment
        -l --latest            update to latest versions of images rather than using those defined in docker-compose.yml
        -p --promote <branch>  promote images in docker repo, from current <branch> to target <branch>
                               this retags the image with the target <branch>,
                                   on protected branches {eg: master or integration } the ':latest' tag is used
                               after a pull request has completed the new images should be pushed to the registry.
        -t --tag <image_tag>   use specific set of image tags

EOF
    exit "$exit_status"
}

#----------------------------------------------------------------------------------------------
# initialize global variables
function deploy.__initGlobals()
{
    local -r base_dir="${1:?}"

    export START_TIME="$(date)"

    [ -e "${base_dir}/.git" ] || trap.die "invalid base directory specified"

    # setup environment
    export CONFIG_DIR="${base_dir}"
    readonly CONFIG_DIR

    export WORKSPACE_DIR="$(deploy.workspace "$base_dir")"
    readonly WORKSPACE_DIR
    export WORKSPACE_YAML="${WORKSPACE_DIR}/docker-compose.yml"


    # verify our basic setup is good
    [ -f "${CONFIG_DIR}/container.os" ] || trap.die "missing 'container.os' file"
    export CONTAINER_OS="$(< "${CONFIG_DIR}/container.os")"
    readonly CONTAINER_OS

    # verify docker-compose.yml in 'config' dir
    export CONFIG_YAML="${CONFIG_DIR}/docker-compose.yml"
    readonly CONFIG_YAML
    [ -e "$CONFIG_YAML" ] || trap.die "Invalid configuration - no $CONFIG_YAML"


    local -i file_count=0
    if [ -d "$WORKSPACE_DIR" ]; then
        local -a files
        mapfile -t files < <(sudo find "$WORKSPACE_DIR" -maxdepth 1 -type f ! -name '*.log' ||:)
        file_count="${#files[*]}"
    fi
    [ "$file_count" -gt 0 ] || deploy.showInitializationBanner


    export VERSIONS_INFO="${CONFIG_DIR}/.versions"
    readonly VERSIONS_INFO

    export LOG_DIR="${base_dir}/logs"
    readonly LOG_DIR

    export SECRETS_DIR="${WORKSPACE_DIR}/.secrets"
    readonly SECRETS_DIR


    export CFG_USER
    : ${CFG_USER:=$(git.user)}
    : ${CFG_USER:=${USERNAME:-}}
    : ${CFG_USER:=${USER:-}}
    CFG_USER="${CFG_USER%@*}"
    export CFG_NAME="${CFG_NAME:-$(git.userName)}"
    export CFG_EMAIL="${CFG_EMAIL:-$(git.userEmail)}"

    [ "${CFG_USER:-}" ] || term.elog 'CFG_USER has not been configured.\n' 'yellow'
    [ "${CFG_NAME:-}" ] || term.elog 'CFG_NAME has not been configured.\n'  'yellow'
    [ "${CFG_EMAIL:-}" ] || term.elog 'CFG_EMAIL has not been configured.\n' 'yellow'
    [ "${CFG_USER:-}" ] && [ "${CFG_NAME:-}" ] && [ "${CFG_EMAIL:-}" ] || deploy.configSettingsHelp
    # verify we have the mandatory env variables defined
    [ "${HOST_IP:-}" ] || term.elog "HOST_IP has not been configured. Please update '$setup_config'"
    [ "${HOST_NAME:-}" ] || term.elog "HOST_NAME has not been configured. Please update '$setup_config'"
    [ "${CFG_USER:-}" ] && [ "${CFG_NAME:-}" ] && [ "${CFG_EMAIL:-}" ] && [ "${HOST_IP:-}" ] && [ "${HOST_NAME:-}" ] || trap.die 'Invalid configuration'

 
    readonly CFG_USER
    readonly CFG_NAME
    readonly CFG_EMAIL

    # import our setup configuration
    lib.exportFileVars "${CONFIG_DIR}/setup.cfg" 'export' 'true'

    # verify that all our environment variables have been set
    deploy.verifyEnvironmentForFile docker-compose.yml

    # enable container logging during startup
    : ${DEBUG_TRACE:=0}
    export DEBUG_TRACE=$(( ++DEBUG_TRACE )) ||:

    # ensure our log dir exists
    [ -d "$LOG_DIR" ] || mkdir -p "$LOG_DIR" ||:
}

#----------------------------------------------------------------------------------------------
# remove any running containers then delete workspace directory
function deploy.clean()
{
    local network
    # check networks to determine if there are running containers
    local -a networks=( $(docker.yamlToJson docker-compose.yml | jq -r '.networks|try .[].name')
                        "$(basename "${WORKSPACE_DIR}")_default"
                       )
    for network in "${networks[@]}"; do
        deploy.down "$network" && break
        deploy.down "${network//./}" && break
    done

    # remove workspace folder
    term.log "\$rm -rf $WORKSPACE_DIR"'\n' 'grey'
    sudo rm -rf "$WORKSPACE_DIR"
}

#----------------------------------------------------------------------------------------------
function deploy.cmdLineArgs()
{
    local base="${1:?}"
    shift
    local usage='deploy.usage'

    # Parse command-line options into above variable
    local -r longOpts='help,Help,HELP,clean,down,init,latest,nodown,promote:,tag:'
    local -r shortOpts='Hhcdilnp:t:'
    local -r progname="$( basename "${BASH_SOURCE[0]}" )"
    local -r options=$(getopt --longoptions "$longOpts" --options "$shortOpts" --name "$progname" -- "$@") || "$usage" $?
    eval set -- "$options"

    local -A opts=()
    [ "$base" ] && opts['base']="$base"
    while true; do
        case "${1:-}" in
            -h|--h|--help|-help)  "$usage" 1;;
            -H|--H|--HELP|-HELP)  "$usage" 1;;
            --Help|-Help)         "$usage" 1;;
            -c|--c|--clean)       opts['clean']=1;          shift;;
            -d|--d|--down)        opts['down']=1;           shift;;
            -i|--i|--init)        opts['init']=1;           shift;;
            -l|--l|--latest)      opts['latest']='HEAD';    shift;;
            -n|--n|--nodown*)     opts['local']=1;          shift;;
            -p|--p|--promote)     opts['promote']=$2;       shift 2;;
            -t|--t|--tag)         opts['container_tag']=$2; shift 2;;
            --)                   shift; break;;
        esac
    done


    # set default value for 
    local tag="${opts['container_tag']:-}"
    if [ -z "${tag:-}" ] && [ -z "${opts['local']:-}" ]; then
        if [ "${CONTAINER_TAG:-}" ]; then
            tag="$CONTAINER_TAG"
        else
            local default
            [ "${opts['latest']:-}" == 'HEAD' ] && default='latest'
            tag="$(deploy.containerTag "${default:-}")"
        fi
        opts['container_tag']="$tag"
    fi


    [ $# -eq 0 ] || term.elog 'Ignoring extra arguments\n' 'warn'
    appenv.results
}

#----------------------------------------------------------------------------------------------
function deploy.configSettingsHelp()
{
cat > /dev/stderr << EOF

Please ensure that your 'git' configuration ( ~/.gitconfig) is valid. It should contain
 
 [user]
     name = Surname, Firstname
     email = first.surname@myorg.com
 [adsk "github"]
     account = ntlogin

You may use the following commands
 
  git config --local --set user.name="Surname, Firstname"
  git config --local --set user.email="first.surname@myorg.com"
  git config --local --set adk.github.account="ntlogin"

EOF
}

#----------------------------------------------------------------------------------------------
function deploy.containerTag()
{
    local -r container_tag=${1:-}

    local branch="$(git.branch)"
    branch="${branch//\//-}"   # replace '/' with '-'
    case "$branch" in
        dev*)                      echo "$branch";;
        master|integration)        echo "${container_tag:-$branch}";;
        *)                         echo 'latest';;
    esac
}

#----------------------------------------------------------------------------------------------
# process line from docker-compose which contains 'image:'
function deploy.containerVersion()
{
    local -r line=${1:?}
    local -r service=${2:?}

    local fingerprint newline prefix production promoted

    # capture prefix up to registry
    prefix="$(sed -Ee 's|^(\s+.*'$(registry.SERVER)'}).*$|\1|' <<< "$line")"

    newline="${line:${#prefix}}"   # strip prefix from line
    promoted="$newline"
    orgimage="$(unset CONTAINER_TAG; eval echo $newline)"
    production="$orgimage"
    fingerprint='<none>'

    # only process lines which have 'CONTAINER_TAG'
    if [[ "$newline" = *CONTAINER_TAG* ]]; then
        local container=$(jq -r '.container_name' <<< "$service")
        if [ "${container:-}" ]; then

            # strip :tag'  suffix
            newline="${newline%:*}"
            [[ "$newline" = *CONTAINER_TAG ]] && newline="${newline%:\${CONTAINER_TAG*}"

            # since this service is running, extract the image name from service, and its fingerprint
            orgimage="$(docker inspect "$container" | jq -r '.[].Config.Image')"
            fingerprint=$(docker inspect "$container" | jq -r '.[].Config.Labels."container.fingerprint"')

            # if the fingerprint exists, replace image tag with fingerprint
            [ "$fingerprint" != 'null' ] && newline=${newline}':${OPTS['container_tag']:-'${fingerprint}'}'

            promoted="$(eval echo $newline)"
            production="$(unset CONTAINER_TAG; eval echo $newline)"
        fi
    else
        promoted="$production"
    fi

    # generate our output JSON
    echo -n '{'
#    echo -n '"version":"'${fingerprint}'",'
#    echo -n '"orgimage":"'${orgimage)'",'
#    echo -n '"newimage":"'${orgimage%:*}':'${fingerprint}'",'
    echo -n '"orgline":"'${line}'",'
    echo -n '"newline":"'${prefix}${newline}'",'
    echo -n '"production":"'${prefix}${production}'",'
    echo -n '"promoted":"'${prefix}${promoted}'"'
    echo '}'
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.createVolumeFolders()
{
    local json="${1:?}"
    local service_name="${2:?}"

    local -a dirs=()
    # find 'volumes'; remove container mount (after ':'); exclude any which start with '/' or '~'
    mapfile -t dirs < <(jq -r ".services.${service_name}.volumes[]?" <<< "$json" \
                       | awk -F ':' '{print $1}' \
                       | grep -Ev '^[/~]' \
                       | sort -u ||:)
    [ "${#dirs[*]}" -eq 0 ] && return 0

    local dir
    for dir in "${dirs[@]}"; do
        [ "${dir:0:2}" = './' ] && dir="${dir:2}"                        # remove './' prefix
        # initialize dir when needed. check if there is a coresponding CONFIG file, and strip filename when file exists
        [ -f "${CONFIG_DIR}/$dir" ] && dir="$(dirname "$dir")"

        if [ ! -d "${WORKSPACE_DIR}/$dir" ]; then
            mkdir -p "${WORKSPACE_DIR}/$dir" ||:
            sudo chown "$EUID" "${WORKSPACE_DIR}/$dir"
            [ "$dir" = "${service_name}/log" ] && chmod 777 "${WORKSPACE_DIR}/$dir"
        fi

        # ensure log symlinks are setup
        if [ "$dir" = "${service_name}/log" ] && [ "$(readlink "${LOG_DIR}/$service_name")" != "${WORKSPACE_DIR}/$dir" ]; then
            # get rid of any old stuff that may prevent us creating symlink
            [ -f "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            [ -h "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            ln -s "${WORKSPACE_DIR}/$dir" "${LOG_DIR}/$service_name"
        fi
    done
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.docker_compose()
{
    local -i status
    (
        [[ -z "${CONTAINER_TAG:-}" && "${OPTS['container_tag']:-}" ]] && export CONTAINER_TAG="${OPTS['container_tag']}"
        docker-compose --file "$WORKSPACE_YAML" "$@"
    ) && status=$? || status=$?

    return $status
}

#----------------------------------------------------------------------------------------------
# down containers
function deploy.down()
{
    local network="${1:?}"
    local -i networks=$(docker network ls | grep -cs "$network")
    [ "$networks" -gt 0 ] || return 1

    # need docker-compose.yml to stop/remove running containers
    mkdir -p "$WORKSPACE_DIR" ||:
    sudo cp "$CONFIG_YAML" "$WORKSPACE_YAML"
    sudo  sed -Ei -e 's|(:\?})|:-}|g' "$WORKSPACE_YAML"

    term.log 'INFO: bringing down containers to allow "workspace" to be refreshed\n' 'lt_magenta'
    term.log '$docker-compose down\n' 'grey'
    deploy.docker_compose down ||:

    return 0
}

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called after containers are running so that up-to-date config info is available
function deploy.fixupDCLineAfterRun()
{
    local line="${1:?}"
    local -r service="${2:?}"
    local -r property="${3:?}"       # property for 'jq' to select from JSON:  '.newline' or '.promoted'
    local -r isConfig="${4:-}"

    # don't copy comments to output
    [ -z "${isConfig:-}" ] && grep -Eq '^\s*#' <<< "$line" && return 0

    # update image definition
    if grep -qsE '^\s+image:\s' <<< "$line"; then
        # update workspace/docker-compose.yml when we pull latest images
        line="$(deploy.containerVersion "$line" "$service" | jq -r "$property")"
    fi

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    while read -r keyName; do
        # 'keyName' is 'SOMEMODULE_VERSION',  '!keyName' is the current/new value of 'xxxxxxxxxxxxxxx'
        line="$(sed -E 's|^(\s+.*\$\{'${keyName}':-)[^\}]+(}.*)$|\1'${!keyName}'\2|' <<< "$line")"
    done < <(awk '/([A-Z0-9]+_VERSION):-/ {sub(":.*","");print substr($0,2)}' RS='$' <<< "$line")


    if [ -z "${isConfig:-}" ] && [ "$(grep -cEs ':\?}' <<< "$line")" -gt 0 ]; then
        local indent="$(sed -Ee 's|^(\s+).*$|\1|' <<< "$line")"
        line="${indent}$(eval echo $line)"
    fi

    echo "$line"
    return 0
}

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called before containers are running so that the workspace 'docker-compose' contains latest user changes
function deploy.fixupDCLineBeforeRun()
{
    local line="${1:?}"
    local -r service="${2:?}"

    # don't copy comments to output
    grep -Eq '^\s*#' <<< "$line" && return 0

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    while read -r keyName; do
        # 'keyName' is 'SOMEMODULE_VERSION',  '!keyName' is the current/new value of 'xxxxxxxxxxxxxxx'
        line="$(sed -E 's|^(\s+.*\$\{'${keyName}':-)[^\}]+(}.*)$|\1'${!keyName}'\2|' <<< "$line")"
    done < <(awk '/([A-Z0-9]+_VERSION):-/ {sub(":.*","");print substr($0,2)}' RS='$' <<< "$line")

    # update default OS with actual OS from container.os file
    local -r os=$(sed -E 's|^\s+.+\$\{CONTAINER_OS:-([^}]+)}.*$|\1|' <<< "$line")
    if grep -qsE 'CONTAINER_OS' <<< "$line" && [ "${CONTAINER_OS}" != "$os" ]; then
        line="$(sed -e 's|'"${os}"'|'"${CONTAINER_OS}"'|' <<< "$line")"

    # if line has required content [ ex: ${HOST:?} ], then attempt to resolve
    elif [ "$(grep -cEs ':\?}' <<< "$line")" -gt 0 ]; then
        local indent="$(sed -Ee 's|^(\s+).*$|\1|' <<< "$line")"
        line="${indent}$(eval echo $line)"
    fi

    echo "$line"
    return 0
}

#----------------------------------------------------------------------------------------------
# setup workspace if it does not exist
function deploy.initialize()
{
    # create WORKSPACE_DIR/docker-compose.yml
    deploy.updateDockerCompose 'createWsYaml'


    local json="$(docker.yamlToJson "$WORKSPACE_YAML")"
    local -ri num_secrets=$(jq '.services[]|select(has("secrets"))|.secrets[]' <<< "$json" | wc -l)
    [ "$num_secrets" -eq 0 ] || deploy.populateSecrets "$SECRETS_DIR"


    # create the folders which are mounted by containers (defined in docker-compose volumes)
    local -A service_tasks=()
    for service_name in $(docker.services "$WORKSPACE_YAML"); do

        # look for individual service tasks (to run later)
        local initFunction="${CONFIG_DIR}/${service_name}.setup"
        [ -e  "$initFunction" ] && service_tasks["$service_name"]="$initFunction"

        # get any defined volumes
        deploy.createVolumeFolders "$json" "$service_name"
    done


    # now run our service tasks
    for task in $(printf '%s\n' "${!service_tasks[@]}" | sort); do
        chmod a+rx "${service_tasks[$task]}"
        "${service_tasks[$task]}" ||:
    done

    # update secret references (cannot apply these with other docker-compose.yml updates)
    [ "$num_secrets" -eq 0 ] || deploy.updateSecretRefs "$WORKSPACE_YAML"
}

#----------------------------------------------------------------------------------------------
function deploy.main()
{
    eval "OPTS=( ${1:?} )"
    readonly OPTS
    shift
    local -ra args=( "$@" )

    deploy.__initGlobals "${OPTS['base']}" "${OPTS['latest']:-}"


    [ -z "${OPTS['clean']:-}" ] || deploy.clean
    mkdir -p "$WORKSPACE_DIR" ||:


    # temporarily reduce DEBUG_TRACE to prevent 'git' tracing
    (( DEBUG_TRACE-- )) ||:
    versions.data "$VERSIONS_INFO" "${OPTS['container_tag']:-}"
    versions.get "$CONTAINER_OS" 'export'
    (( DEBUG_TRACE++ )) ||:

    if [ "${OPTS['init']:-}" ]; then
        #  initialize devops_container_environment
        term.log '$deploy.initialize 2>&1 | tee setup.log\n' 'grey'
        deploy.initialize 2>&1 | tee "${WORKSPACE_DIR}/setup.log"
        exit 0
    fi

    if [ "${OPTS['down']:-}" ] && [ -f "$WORKSPACE_YAML" ]; then
        # stop any running containers
        term.log '\nINFO: bringing down containers\n' 'white'
        term.log 'docker-compose --file '"$WORKSPACE_YAML"' down\n' 'grey'
        deploy.docker_compose down ||:
        exit 0
    fi

    #  restart devops_container_environment  (performs configuration if needed)
    term.log '$deploy.restart 2>&1 | tee restart.log\n' 'grey'
    deploy.restart "${OPTS['latest']:-}" 2>&1 | tee "${WORKSPACE_DIR}/restart.log"
}

#----------------------------------------------------------------------------------------------
# used by '......setup' files
function deploy.passwordSecret()
{
    local -r service=${1:?}
    local -r pwdVar=${2:?}

    local secret jqquery
    local -r json="$(docker.yamlToJson "$WORKSPACE_YAML")"
    local password="$(jq -r '.services.'${service}'.environment.'${pwdVar} <<< "$json" )"
    if [ "$password" = 'null' ];then
        password="$(jq -r '.services.'${service}'.environment.'${pwdVar}'_FILE' <<< "$json" )"
        secret="$(basename "$password")"
        jqquery='.secrets."'"${secret}"'".file'
        local pwd_file="$(eval echo "$(jq -r "$jqquery" <<< "$json" )")"
        [ -e "$pwd_file" ] || trap.die "Password file: '$pwd_file' not found. Used by startup of service: $service"
        password=$(< "$pwd_file")
    fi
    echo "$password"
}
export -f deploy.passwordSecret

#----------------------------------------------------------------------------------------------
function deploy.populateSecrets()
{
    local -r secrets_dir=${1:-}

    if [ -d "$secrets_dir" ]; then
        # secrets_dir already exists. no need to populate
        :

    elif [ -z "${CFG_USER_SECRETS:-}" ]; then
        [ "${OPEN_SECRETS_REPO:-}" ] || trap.die  "no definition provided for 'secrets'"
        term.log 'populating '"$secrets_dir"' with user defined secrets\n'
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$OPEN_SECRETS_REPO" "$secrets_dir"

    elif [ -d "${CFG_USER_SECRETS}" ] && [ "$(readlink -f "$CFG_USER_SECRETS")" != "$(readlink -f "$secrets_dir")" ]; then
        term.log 'populating '"$secrets_dir"' from local secrets dir\n'
        mkdir -p "$secrets_dir"
        cp -r "${CFG_USER_SECRETS}"/* "$secrets_dir"/

    elif git.lsRemote "${CFG_USER_SECRETS}" &> /dev/null ; then
        term.log 'populating '"$secrets_dir"' from git secrets\n'
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$CFG_USER_SECRETS" "$secrets_dir" --quiet
        if [ "$(grep -cs 'git-crypt' "${secrets_dir}/.gitattributes")" -gt 0 ]; then
            [ -e "${CRYPT_FILE:-}" ] || trap.die "secrets are encoded, but CRYPT_FILE: '${CRYPT_FILE:-}' does not exist"
            (cd "$secrets_dir"; git.cryptUnlock )
        fi

    else
        trap.die  "missing 'secrets' directory in WORKSPACE_DIR"
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.pushImages()
{
    local -r dc_yaml=${1:?}

    local image service srvc
    local -a images=()

    local -r json=$(docker.yamlToJson "$dc_yaml")

    # extract images from docker-compose
    while read -r srvc; do
        service=$(jq ".services.$srvc" <<< "$json")
        image="$(eval echo "$(jq -r '.image' <<< "$service")" )"
        images+=( "$image" )
    done < <(jq -r '.services|keys[]' <<< "$json")

    docker.pushRetained 1 "${images[@]}"
}

#----------------------------------------------------------------------------------------------
function deploy.refreshContainers()
{
    # make sure we start the correct versions
    if [ "${OPTS['dev']:-}" ]; then
        return 0
    elif [ "${OPTS['container_tag']:-}" = 'latest' ]; then
        term.log '\nINFO: updating containers to latest versions\n' 'white'
    else
        term.log '\n'"INFO: using container fingerprints defined in docker-compose.yml"'\n' 'white'
    fi
    term.log 'docker-compose --file '"$WORKSPACE_YAML"' pull\n' 'grey'
    deploy.docker_compose pull || return 1
}

#----------------------------------------------------------------------------------------------
function deploy.removeCBFlogs()
{
    while read -r dir; do
        [ -f "${dir}/cbf.log" ] || continue
        sudo rm "${dir}/cbf.log"
    done < <(find "$WORKSPACE_DIR" -mindepth 2 -maxdepth 2 -type d -name log)
}

#----------------------------------------------------------------------------------------------
function deploy.replaceIpAddresses()
{
    local -r filename=${1:?}
    local -r host_ip=${2:?}

    if [ -e "$filename" ]; then
        local -r ip_match_rgx='((1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])'
        local expr="'s#${ip_match_rgx}#${host_ip}#g'"
        eval sed -i -r -e "$expr" "$filename"
    fi
}
export -f deploy.replaceIpAddresses

#----------------------------------------------------------------------------------------------
function deploy.restart()
{
    local latest=${1:-}

    echo "CONTAINER_TAG: ${OPTS['container_tag']:-<using default>}" >&2

    # initialize workspace if required 'docker-compose.yml' is missing
    mkdir -p "$WORKSPACE_DIR" ||:
    cd "$WORKSPACE_DIR"

    deploy.initialize
    deploy.removeCBFlogs

    # restart our environment
    if ! deploy.restartContainers "$latest"; then
        term.log 'Failed to succussfully deploy container services.\n' 'white'
        exit 0
    fi

    local -r run_log="${WORKSPACE_DIR}/run.log"
    deploy.waitForInitializationComplete "$WORKSPACE_YAML" "$run_log"

    term.log '\nINFO: removing old containers\n' 'white'
    docker.clean

    docker.showProcessReport
    echo

    # show help at end of deploy
    [ "${INITIALIZE_COMPLETE:-}" ] && term.log 'Initializing complete.\n' 'white'
    if [ -e "${CONFIG_DIR}/completionMsg" ]; then
        local msg="$(< ${CONFIG_DIR}/completionMsg)"
        term.log "$(eval "echo $msg")"'\n' 'white'
    fi
    exit 0
}

#----------------------------------------------------------------------------------------------
function deploy.restartContainers()
{
    local -r latest=${1:-}
    local -i status

    # stop any running containers
    term.log '\nINFO: bringing down containers\n' 'white'
    term.log 'docker-compose --file '"$WORKSPACE_YAML"' down\n' 'grey'
    deploy.docker_compose down ||:

    set -o verbose
    sudo find -L "$LOG_DIR" -type f ! -name '.*' -delete
    set +o verbose

    deploy.refreshContainers && status=$? || status=$?
    [ $status -eq 0 ] || return $status

    term.log '\nINFO: bringing up containers\n' 'white'
    term.log 'docker-compose --file '"$WORKSPACE_YAML"' up --detach\n' 'grey'
    # docker-compose v1.17.0 does not like '--detach'!
    deploy.docker_compose up -d  && status=$? || status=$?
    [ $status -eq 0 ] || return $status

    # fixup docker-compose.yml to reflect the image versions in use
    if [ "${latest:-}" = 'HEAD' ]; then
        echo
        # Updating reference docker-compose.yml
        deploy.updateDockerCompose 'updateWsYaml'
        deploy.updateDockerCompose 'updateCfgYaml'
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.reTagImages()
{
    local -r dc_yaml=${1:?}

    local image retaggedImage
    while read -r image; do
        image="$(eval echo $image)"
        if [ $(docker images | grep -cs "$image") -gt 0 ]; then
            retaggedImage="${image%=*}"
            term.log "renaming $image to ${retaggedImage}:${OPTS['container_tag']}"'\n' 'warn'
            docker tag "$image" "${retaggedImage}:${OPTS['container_tag']}"
        else
            term.log "no images matching $image"'\n' 'warn'
        fi
    done < <(grep -E '^\s+image:\s' "$dc_yaml" | sed -E -e 's|^\s+image:\s+||' )
}

#----------------------------------------------------------------------------------------------
function deploy.showInitializationBanner()
{
    term.log '******************************************************************************\n' 'white'
    term.log '*                                                                            *\n' 'white'
    term.log "*  initializing DevOps Container Environment on $(environ.ipAddress)"'\n'         'white'
    term.log '*                                                                            *\n' 'white'
    term.log '******************************************************************************\n' 'white'
    export INITIALIZE_COMPLETE='true'
}

#----------------------------------------------------------------------------------------------
function deploy.toProduction()
{
    local -r dc_yaml=${1:?}

    #  verify repo is not dirty
    #  verify latest is running
    #  verify branch is not protected

    #  retag images
    #  push images to registry
    #  update workspace docker-compose
    #  update deploy docker-compose

    #  update main docker-compose.yml if this is for promotion
    if [ "${OPTS['container_tag']:-}" != 'latest' ]; then
        deploy.reTagImages "$dc_yaml"
        # Updating reference docker-compose.yml
        deploy.updateDockerCompose 'production'
        # now update docker registry
        deploy.pushImages "$dc_yaml"
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.updateDockerCompose()
{
    local -r mode=${1:?}

    local dst_yaml json process src_yaml
    local -a args=()

    # setup the conditions to control how docker.compose gets updated
    case "$mode" in
        createWsYaml)
            # update skip.wait & docker-compose
            cp "${CONFIG_DIR}/skip.wait" "${WORKSPACE_DIR}/skip.wait"
            src_yaml="$CONFIG_YAML"
            dst_yaml="$WORKSPACE_YAML"
            process='deploy.fixupDCLineBeforeRun'
            ;;

        updateWsYaml)
            cp "${CONFIG_DIR}/skip.wait" "${WORKSPACE_DIR}/skip.wait"
            src_yaml="$CONFIG_YAML"
            dst_yaml="$WORKSPACE_YAML"
            process='deploy.fixupDCLineAfterRun'
            json=$(docker.yamlToJson "$dst_yaml")
            args=( '.newline' )
            ;;

        updateCfgYaml)
            src_yaml="$CONFIG_YAML"
            dst_yaml="$CONFIG_YAML"
            process='deploy.fixupDCLineAfterRun'
            json=$(docker.yamlToJson "$dst_yaml")
            args=( '.newline' 'isConfig' )
            ;;

        promote)
            src_yaml="$CONFIG_YAML"
            dst_yaml="$CONFIG_YAML"
            process='deploy.fixupDCLineAfterRun'
            json=$(docker.yamlToJson "$dst_yaml")
            args=( '.promoted' 'isConfig' )
            ;;

        production)
            src_yaml="$CONFIG_YAML"
            dst_yaml="$CONFIG_DIR/docker-compose.master.yml"
            process='deploy.fixupDCLineAfterRun'
            json=$(docker.yamlToJson "$WORKSPACE_YAML")
            args=( '.production' 'isConfig' )
            ;;

        *)
            trap.die "Invalid option passed to 'function ${FUNCNAME[0]}()'"
            ;;
    esac


    local -a services="$(docker.yamlToJson "$src_yaml" | jq -r '.services|keys[]')"
    local tmp_file="${dst_yaml#.*}.tmp"
    (
        local service='null'
        local key=''
        while read -r line; do

            # skip blank lines
            if [ -z "${line:-}" ] || grep -sq '^\s+$' <<< "$line" ; then
                echo
                continue
            fi

            # look for 'service' definition  (capture start of line, to [:#], then look for key)
            key="$(sed -E -e 's|^(.+?[:#])\s.*$|\1|' <<< "$line" | sed -E -e 's|^\s+(\w+):\s*$|\1|')"
            if [ "${key:-}" ] && [ "${json:-}" ]; then

                # find service that defines image
                grep -qE '^\s+'"${key}"':\s*$' <<< "$line" && \
                    grep -q "$key" <<< "$services" && \
                    service=$(jq ".services.$key" <<< "$json")
            fi

            # process line
            if ! "$process" "$line" "$service" "${args[@]:-}"; then
                term.elog "Failed to process $line"'\n' 'warn'
                break
            fi
        done < <(cat "$src_yaml")
    ) > "$tmp_file"

    # if there are no changes, delete tmp file
    if [ "$(lib.fileSha256 "$dst_yaml")" = "$(lib.fileSha256 "$tmp_file")" ]; then
        rm "$tmp_file"
        return 0   # no updates
    fi

    # otherwise rename 'src_yaml' to file.YYYYMMDDhhmmss.bak and rename updated file to 'dst_yaml'
    # create backup of dstfile before we update it
    term.log "INFO: updating ${dst_yaml}"'\n' 'white'
    if [ -f "$dst_yaml" ]; then
        local backup="${dst_yaml%.*}.$(date +"%Y%m%d%H%M%S").${dst_yaml##*.}.bak"
        backup="$(dirname "$backup")/~$(basename "$backup")"
        mv "$dst_yaml" "$backup"
    fi
    mv "$tmp_file" "$dst_yaml"   # file updated
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.updateSecretRefs()
{
    local -r dc_yaml=${1:?}
    sed -i -r -e 's|file:\s+~/|file: '"$(readlink -f ~)"'/|' "$dc_yaml"
}

#----------------------------------------------------------------------------------------------
function deploy.validateDockerComposeYaml()
{
    local -r dc_yaml=${1:?}
    [ $(jq '.services[].ports[]' <<< "$dc_yaml" | sort | wc -l) -eq $(jq '.services[].ports[]' <<< "$dc_yaml"| sort -u) ] || return 1
}

#----------------------------------------------------------------------------------------------
function deploy.verifyEnvironmentForFile()
{
    local -r file=${1:?}

    local var
    local -a unknown=()
    while read -r var; do
        [ -z "${!var:-}" ] && unknown+=( "$var" )
    done < <(grep -v '\s*#'  "$file" | grep -F ':?}' | sed -E -e 's|.*\$\{||' -e 's|:\?\}.*$||' | sort -u ||: )

    if [ ${#unknown[*]} -gt 0 ]; then
        trap.die 'The following environment variables are undefined:'$(printf '\n    %s' "${unknown[@]}")
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.waitForInitializationComplete()
{
    local -r dc_yaml=${1:?}
    local -r run_log=${2:?}

    # get the list of containers we will be checking
    local -a containers
    mapfile -t containers < <(docker.services "$dc_yaml")


    # initialize the log
    echo "Started at: ${START_TIME}" > "$run_log"

    local -A finished=( )
    local -a lines=()
    local container line
    local -i index=1

    term.log '\n'"INFO: waiting for ${#containers[*]} containers to complete their startup"'\n' 'white'
    while [ "${#finished[*]}" -lt "${#containers[*]}" ]; do
        # sleep 5 secs between scans
        sleep 5
        lines=()

        # check all known containers
        for container in "${containers[@]}"; do
            # ignore any that are defined in 'skip.wait'
            if [ $(grep -cs "$container" "${WORKSPACE_DIR}/skip.wait") -gt 0 ] && [ -z "${finished[${container,,}]:-}" ]; then
                printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
                finished[$container]='0'
            fi

            # look for specific 'end of startup' string in logs
            local text="$(docker logs "${container,,}" 2>&1 | grep -s "Finished executing startup" | head -1 ||: )"
            [ "$text" ] || continue                                        # ignore blank lines
            [ "${container,,}" ] || continue                               # ignore invalid container
            [ -z "${finished[${container,,}]:-}" ] || continue             # ignore if we already have this result

            # keep track of what has finished
            finished[${container,,}]="$text"
            lines+=( "$(sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$text" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }')_${container,,}" )
        done

        # print out any containers we found in this scan
        [ "${#lines[*]}" -gt 0 ] || continue
        for line in $(printf '%s\n' "${lines[@]}" | sort -t '_' -k 1n,2); do   # sort by time taken to finish startup
            container="${line##*_}"                                            # extract container name
            container="${container,,}"
            printf '%02d. %s\n' $(( index++ )) "${finished[${container}]:-}"
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        done
    done

    # update the run.log from each 'docker logs'
    for container in "${containers[@]}"; do
        if [ $(grep -cs "$container" "${WORKSPACE_DIR}/skip.wait") -gt 0 ]; then
          {
            echo 
            echo '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
            echo "${container}"
            echo
            docker logs "${container}" 2>&1                      # grab the log
          } >> "$run_log"
        fi
    done
}

#----------------------------------------------------------------------------------------------
function deploy.workspace()
{
    local -r base_dir=${1:?}
    echo "${base_dir}/workspace.$(basename "$base_dir")"
}

#----------------------------------------------------------------------------------------------
#
#      MAIN
#
#----------------------------------------------------------------------------------------------

declare -i status

declare -A OPTS
declare -r PROGNAME="$( basename "${BASH_SOURCE[0]}" )"
declare -r PROGRAM_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
declare -i IS_DEBUG=${DEBUG:-0}


declare -r loader="$PROGRAM_DIR/appenv.bashlib"
if [ ! -e "$loader" ]; then
    echo 'Unable to load libraries'
    exit 1
fi

source "$loader"
appenv.loader 'deploy.main'

declare -a args=( $( deploy.cmdLineArgs "$PWD" "$@" ) ) && status=$? || status=$?
[ $status -eq 0 ] && deploy.main "${args[@]}" && status=$? || status=$? 
exit $status 
