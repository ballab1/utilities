#!/bin/bash

#----------------------------------------------------------------------------------------------
function deploy.usage()
{
    local -i exit_status=${1:-1}

    cat >&2 << EOF
Usage:
    $PROGNAME [ -h|--help ]
              | [ --clean ]
              | [ --dev ]
              | [ --down ]
              | [ --init ]
              | [ --latest ]
              | [ --tag <image_tag> ]

    Common options:
        -h --help              Display a basic set of usage instructions
        -c --clean             0:do not clean environment
                               1:clean environment before build (default)
           --dev               do not pull new images from registry (use images on local system)
        -d --down              stop services defined by 'docker-compose.yml'
        -i --init              only initialize the environment
        -l --latest            update to latest versions of images rather than using those defined in docker-compose.yml
        -t --tag <image_tag>   use specific set of image tags

EOF
    exit "$exit_status"
}

#----------------------------------------------------------------------------------------------
# initialize global variables
function deploy.__initGlobals()
{
    local -r base_dir="${1:?}"

    export START_TIME="$(date)"

    [ -e "${base_dir}/.git" ] || trap.die "invalid base directory specified"

    # setup environment
    export CONFIG_DIR="${base_dir}"
    readonly CONFIG_DIR

    export DEPLOY_YAML="${CONFIG_DIR}/deploy.yml"
    [ -e "$DEPLOY_YAML" ] || trap.die "Unable to locate deploy configuration file: $DEPLOY_YAML"
    readonly DEPLOY_YAML

    local deploy_json="$(lib.yamlToJson "$DEPLOY_YAML")"

    # verify our basic setup is good
    export CONTAINER_OS="$(jq --compact-output --monochrome-output --raw-output 'try .container_os' <<< "$deploy_json" ||:)"
    [ "${CONTAINER_OS:-}" ] || trap.die "missing 'container.os' section in $deploy_json"
    readonly CONTAINER_OS

    export WORKSPACE_DIR="$(deploy.workspace "$base_dir")"
    readonly WORKSPACE_DIR
    export WORKSPACE_YAML="${WORKSPACE_DIR}/docker-compose.yml"

    # verify docker-compose.yml in 'config' dir
    export CONFIG_YAML="${CONFIG_DIR}/docker-compose.yml"
    readonly CONFIG_YAML
    [ -e "$CONFIG_YAML" ] || trap.die "Invalid configuration - no $CONFIG_YAML"


    local -i file_count=0
    if [ -d "$WORKSPACE_DIR" ]; then
        local -a files
        mapfile -t files < <(sudo find "$WORKSPACE_DIR" -maxdepth 1 -type f ! -name '*.log' ||:)
        file_count="${#files[*]}"
    fi
    [ "$file_count" -gt 0 ] || deploy.showInitializationBanner


    export LOG_DIR="${base_dir}/logs"
    readonly LOG_DIR

    export SECRETS_DIR="${WORKSPACE_DIR}/.secrets"
    readonly SECRETS_DIR

    export CFG_USER
    : ${CFG_USER:=$(git.user)}
    : ${CFG_USER:=${USERNAME:-}}
    : ${CFG_USER:=${USER:-}}
    CFG_USER="${CFG_USER%@*}"
    export CFG_NAME="${CFG_NAME:-$(git.userName)}"
    export CFG_EMAIL="${CFG_EMAIL:-$(git.userEmail)}"
    environ.container

    local -A deps=()
    local key val
    local -i idx

    # import our setup configuration  (combine 'environment and thirdparty_versions' as they are only separate for readability)
    local json="$(jq --compact-output --monochrome-output '[.environment + .thirdparty_versions|to_entries[]]' <<< "$deploy_json")"
    local -i numkeys=$(jq --compact-output --monochrome-output --raw-output 'length' <<< "$json")

    for (( idx=0; idx<numkeys; idx++ )); do
        key="$(jq --compact-output --monochrome-output --raw-output ".[$idx].key" <<< "$json")"
        val="$(jq --compact-output --monochrome-output --raw-output ".[$idx].value" <<< "$json")"
        if (eval export "$key=$val" 2>/dev/null); then
            eval export "$key=$val"
            readonly "$key"
        else
            deps[$key]="$val"
        fi
    done
    for key in "${!deps[@]}"; do
        val="${deps[$key]}"
        eval export "$key=$val"
        readonly "$key"
    done


    # verify we have the mandatory env variables defined
    [ "${CFG_USER:-}" ] || term.elog 'CFG_USER has not been configured.\n' 'yellow'
    [ "${CFG_NAME:-}" ] || term.elog 'CFG_NAME has not been configured.\n'  'yellow'
    [ "${CFG_EMAIL:-}" ] || term.elog 'CFG_EMAIL has not been configured.\n' 'yellow'
    [[ "${CFG_USER:-}" && "${CFG_NAME:-}" && "${CFG_EMAIL:-}" ]] || deploy.configSettingsHelp
    [[ -z "${HOST_IP:-}" || "${HOST_IP}" = *\ * ]] && trap.die 'HOST_IP is invalid or has not been configured. Please update the '\''environment'\'' section in deploy.yml'
    [ "${HOST_NAME:-}" ] || term.elog 'HOST_NAME has not been configured. Please update the '\''environment'\'' section in deploy.yml\n'
    [[ "${CFG_USER:-}" && "${CFG_NAME:-}" && "${CFG_EMAIL:-}" && "${HOST_IP:-}" && "${HOST_NAME:-}" ]] || trap.die 'Invalid configuration'
    [[ "${CFG_USER:-}" != root ]] || trap.die 'Deploy of packages as root user is not permitted\n'

 
    readonly CFG_USER
    readonly CFG_NAME
    readonly CFG_EMAIL


    # verify that all our environment variables have been set
    deploy.verifyEnvironmentForFile docker-compose.yml

    # enable container logging during startup
    : ${DEBUG_TRACE:=0}
    export DEBUG_TRACE=$(( ++DEBUG_TRACE )) ||:

    # ensure our log dir exists
    [ -d "$LOG_DIR" ] || mkdir -p "$LOG_DIR" ||:

    if [ "$(jq 'has("skip_wait")' <<< "$deploy_json")" = 'true' ]; then
        mapfile -t SKIP_WAIT < <(jq --compact-output --monochrome-output --raw-output '.skip_wait[]' <<< "$deploy_json" ||:)
    else
        SKIP_WAIT=()
    fi

    # verify our basic setup is good
    mapfile -t COMPLETION_MSG < <(jq --compact-output --monochrome-output --raw-output 'try .completion_msg[]' <<< "$deploy_json" ||:)
    readonly COMPLETION_MSG
}

#----------------------------------------------------------------------------------------------
# remove any running containers then delete workspace directory
function deploy.clean()
{
    local network
    # check networks to determine if there are running containers
    local -a networks=( $(lib.yamlToJson docker-compose.yml | jq --compact-output --monochrome-output --raw-output '.networks|try .[].name' ||:)
                        "$(basename "${WORKSPACE_DIR}")_default"
                       )
    for network in "${networks[@]}"; do
        deploy.down "$network" && break
        deploy.down "${network//./}" && break
    done

    # remove workspace folder
    term.log "\$rm -rf $WORKSPACE_DIR"'\n' 'grey'
    sudo rm -rf "$WORKSPACE_DIR"
}

#----------------------------------------------------------------------------------------------
function deploy.cmdLineArgs()
{
    # Parse command-line options into above variable
    local -r longOpts='help,Help,HELP,base:,clean,debug,dev,down,init,latest,nodown,tag:'
    local -r shortOpts='Hhb:cdilnt:'
    local -r options=$(getopt --longoptions "$longOpts" --options "$shortOpts" --name "$PROGNAME" -- "$@") || deploy.usage $?
    eval set -- "$options"

    local -A opts=( ['base']="$(pwd)" )
    [ "${DEBUG:-}" ] && opts['debug']="$DEBUG"

    while [ "${1:-}" ]; do
        case "${1,,}" in
            -h|--h|--help|-help)       deploy.usage 1;;
            -b|--b|--base)             opts['base']="$2";        shift 2;;
            -c|--c|--clean)            opts['clean']=1;          shift;;
                   --debug)            opts['debug']=1;          shift;;
                   --dev)              opts['dev']=1;            shift;;
            -d|--d|--down)             opts['down']=1;           shift;;
            -i|--i|--init)             opts['init']=1;           shift;;
            -l|--l|--latest)           opts['latest']='HEAD';    shift;;
            -n|--n|--nodown*)          opts['local']=1;          shift;;
            -t|--t|--tag)              opts['container_tag']=$2; shift 2;;
            --)                        shift; break;;
            *)                         break;;
        esac
    done


    # set default value for 
    local tag="${opts['container_tag']:-}"
    if [ -z "${tag:-}" ] && [ -z "${opts['latest']:-}" ]; then
        if [ "${CONTAINER_TAG:-}" ]; then
            tag="$CONTAINER_TAG"
        elif [ "${opts['latest']:-}" ]; then
            local default
            [ "${opts['latest']}" == 'HEAD' ] && default='latest'
            tag="$(deploy.containerTag "${default:-}")"
        fi
    fi
    [ -z "${tag:-}" ] || opts['container_tag']="${tag//\//-}"   # replace '/' with '-'


    # show args
    if [ ${opts['debug']:-0} -gt 0 ]; then
        {
            for i in "${!opts[@]}"; do
               printf '%s: %s\n' "$i" "${opts[$i]}"
            done
            echo 'args:'
            for i in "$@"; do
               printf '   %s\n' "$i"
            done
            echo
        } >&2
    fi
 
    [ $# -eq 0 ] || term.elog 'Ignoring extra arguments\n' 'warn'
    appenv.results
}

#----------------------------------------------------------------------------------------------
function deploy.configSettingsHelp()
{
cat > /dev/stderr << EOF

Please ensure that your 'git' configuration ( ~/.gitconfig) is valid. It should contain
 
 [user]
     name = Surname, Firstname
     email = first.surname@myorg.com
 [adsk "github"]
     account = ntlogin

You may use the following commands
 
  git config --local --set user.name="Surname, Firstname"
  git config --local --set user.email="first.surname@myorg.com"
  git config --local --set adk.github.account="ntlogin"

EOF
}

#----------------------------------------------------------------------------------------------
function deploy.containerTag()
{
    local -r container_tag=${1:-}

    local branch="$(git.branch)"
    branch="${branch//\//-}"   # replace '/' with '-'
    case "$branch" in
        dev*)                      echo "$branch";;
        master|integration)        echo "${container_tag:-$branch}";;
        *)                         echo 'latest';;
    esac
}

#----------------------------------------------------------------------------------------------
# process line from docker-compose which contains 'image:'
function deploy.containerVersion()
{
    local -r line=${1:?}
    local -r service=${2:?}

    local fingerprint newline prefix production promoted

    # capture prefix up to registry
    prefix="$(sed -Ee 's|^(\s+.*'"$(registry.SERVER)"'}).*$|\1|' <<< "$line")"

    newline="${line:${#prefix}}"   # strip prefix from line
    promoted="$newline"
    orgimage="$(unset CONTAINER_TAG; eval "echo $newline")"
    production="$orgimage"
    fingerprint='<none>'

    # only process lines which have 'CONTAINER_TAG'
    if [[ "$newline" = *CONTAINER_TAG* ]]; then
        local container=$(jq --compact-output --monochrome-output --raw-output '.container_name' <<< "$service")
        if [ "${container:-}" ]; then

            # strip :tag'  suffix
            newline="${newline%:*}"
            [[ "$newline" = *CONTAINER_TAG ]] && newline="${newline%:\${CONTAINER_TAG*}"

            # since this service is running, extract the image name from service, and its fingerprint
            orgimage="$(docker inspect "$container" | jq --compact-output --monochrome-output --raw-output '.[].Config.Image')"
            fingerprint=$(docker inspect "$container" | jq --compact-output --monochrome-output --raw-output '.[].Config.Labels."container.fingerprint"')

            # if the fingerprint exists, replace image tag with fingerprint
            [ "$fingerprint" != 'null' ] && newline="${newline}"':${CONTAINER_TAG:-'"${fingerprint}"'}'

            promoted="$(eval echo $newline)"
            production="$(unset CONTAINER_TAG; eval echo $newline)"
        fi
    else
        promoted="$production"
    fi

    # generate our output JSON
    echo -n '{'
#    echo -n '"version":"'${fingerprint}'",'
#    echo -n '"orgimage":"'${orgimage)'",'
#    echo -n '"newimage":"'${orgimage%:*}':'${fingerprint}'",'
    echo -n '"orgline":"'${line}'",'
    echo -n '"newline":"'${prefix}${newline}'",'
    echo -n '"production":"'${prefix}${production}'",'
    echo -n '"promoted":"'${prefix}${promoted}'"'
    echo '}'
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.createVolumeFolders()
{
    local json="${1:?}"
    local service_name="${2:?}"

    local -a dirs=()
    # find 'volumes'; remove container mount (after ':'); exclude any which start with '/' or '~'
    mapfile -t dirs < <(jq --compact-output --monochrome-output --raw-output ".services.${service_name}.volumes[]?" <<< "$json" \
                       | awk -F ':' '{print $1}' \
                       | grep -Ev '^[/~]' \
                       | sort -u ||:)
    [ "${#dirs[*]}" -eq 0 ] && return 0

    local dir
    for dir in "${dirs[@]}"; do
        [ "${dir:0:2}" = './' ] && dir="${dir:2}"                        # remove './' prefix
        # initialize dir when needed. check if there is a coresponding CONFIG file, and strip filename when file exists
        [ -f "${CONFIG_DIR}/$dir" ] && dir="$(dirname "$dir")"

        if [ ! -d "${WORKSPACE_DIR}/$dir" ]; then
            mkdir -p "${WORKSPACE_DIR}/$dir" ||:
            sudo chown "$EUID" "${WORKSPACE_DIR}/$dir"
            [ "$dir" = "${service_name}/log" ] && chmod 777 "${WORKSPACE_DIR}/$dir"
        fi

        # ensure log symlinks are setup
        if [ "$dir" = "${service_name}/log" ] && [ "$(readlink "${LOG_DIR}/$service_name")" != "${WORKSPACE_DIR}/$dir" ]; then
            # get rid of any old stuff that may prevent us creating symlink
            [ -f "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            [ -h "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            ln -s "${WORKSPACE_DIR}/$dir" "${LOG_DIR}/$service_name"
        fi
    done
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.docker_compose()
{
    local -i status
    # execute in subshell so as to isolate 'CONTAINER_TAG' variable used in docker-compose.yml
    (
        [[ -z "${CONTAINER_TAG:-}" && "${OPTS['container_tag']:-}" ]] && export CONTAINER_TAG="${OPTS['container_tag']}"
        docker-compose --file "$WORKSPACE_YAML" "$@"
    ) && status=$? || status=$?

    return $status
}

#----------------------------------------------------------------------------------------------
# down containers
function deploy.down()
{
    local network="${1:?}"
    local -i networkCount=$(docker network ls | grep -cs "$network")
    [ "$networkCount" -gt 0 ] || return 1

    # need docker-compose.yml to stop/remove running containers
    mkdir -p "$WORKSPACE_DIR" ||:
    sudo cp "$CONFIG_YAML" "$WORKSPACE_YAML"
    sudo  sed -Ei -e 's|(:\?})|:-}|g' "$WORKSPACE_YAML"

    term.log 'INFO: bringing down containers to allow "workspace" to be refreshed\n' 'lt_magenta'
    term.log '$docker-compose down --remove-orphans\n' 'grey'
    deploy.docker_compose down --remove-orphans ||:

    return 0
}

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called after containers are running so that up-to-date config info is available
function deploy.fixupDCLineAfterRun()
{
    local line="${1:?}"
    local -r service="${2:?}"
    local -r property="${3:?}"       # property for 'jq' to select from JSON:  '.newline' or '.promoted'
    local -r isConfig="${4:-}"

    # don't copy comments to output
    [ -z "${isConfig:-}" ] && grep -Eq '^\s*#' <<< "$line" && return 0

    # update image definition
    if grep -qsE '^\s+image:\s' <<< "$line"; then
        # update workspace/docker-compose.yml when we pull latest images
        line="$(deploy.containerVersion "$line" "$service" | jq --compact-output --monochrome-output --raw-output "$property")"
    fi

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    while read -r keyName; do
        [ -z "${!keyName:-}" ] && trap.die "unrecognized VERSION parameter $keyName used."
        # 'keyName' is 'SOMEMODULE_VERSION',  '!keyName' is the current/new value of 'xxxxxxxxxxxxxxx'
        line="$(sed -E 's|^(\s+.*\$\{'"$keyName"':-)[^\}]+(}.*)$|\1'"${!keyName}"'\2|' <<< "$line")"
    done < <(awk '/([A-Z0-9]+_VERSION):-/ {sub(":.*","");print substr($0,2)}' RS='$' <<< "$line")

    if [ -z "${isConfig:-}" ] && [ "$(grep -cEs ':\?}' <<< "$line")" -gt 0 ]; then
        local indent="$(sed -Ee 's|^(\s+).*$|\1|' <<< "$line")"
        line="${indent}$(eval "echo $line")"
    fi

    echo "$line"
    return 0
}

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called before containers are running so that the workspace 'docker-compose' contains latest user changes
function deploy.fixupDCLineBeforeRun()
{
    local line="${1:?}"
    local -r service="${2:?}"

    # don't copy comments to output
    grep -Eq '^\s*#' <<< "$line" && return 0

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    while read -r keyName; do
        [ -z "${!keyName:-}" ] && continue

        # 'keyName' is 'SOMEMODULE_VERSION',  '!keyName' is the current/new value of 'xxxxxxxxxxxxxxx'
        line="$(sed -E 's|^(\s+.*\$\{'${keyName}':-)[^\}]+(}.*)$|\1'${!keyName}'\2|' <<< "$line")"
    done < <(awk '/([A-Z0-9]+_VERSION):-/ {sub(":.*","");print substr($0,2)}' RS='$' <<< "$line")

    # update default OS with actual OS from container.os file
    local -r os=$(sed -E 's|^\s+.+\$\{CONTAINER_OS:-([^}]+)}.*$|\1|' <<< "$line")
    if grep -qsE 'CONTAINER_OS' <<< "$line" && [ "${CONTAINER_OS}" != "$os" ]; then
        line="$(sed -e 's|'"${os}"'|'"${CONTAINER_OS}"'|' <<< "$line")"

    # if line has required content [ ex: ${HOST:?} ], then attempt to resolve
    elif [ "$(grep -cEs ':\?}' <<< "$line")" -gt 0 ]; then
        local indent="$(sed -Ee 's|^(\s+).*$|\1|' <<< "$line")"
        line="${indent}$(eval echo $line)"
    fi

    echo "$line"
    return 0
}

#----------------------------------------------------------------------------------------------
# parse all BASH tokens/variables from a file
function deploy.getTokens() {
  local file="${1:?}"

  ########    | *removeUnwantedLines*      | *removeTrailingSpaces, separateTokens* | *removeUnwantedLines*      | *identifyTokens* | *removeTokenStart,     removeTokenEndings,       setKeyValDelim,          fixUndefinedTokens*
  cat "$file" | grep -vE '^((\s*)|(#.*))$' | sed -E -e 's|\s+$||'   -e 's|\$|\n$|g' | grep -vE '^((\s*)|(#.*))$' | grep '\$'        | sed -E -e 's|^\$\{?||' -e 's|"||' -e 's|\}.*$||' -e 's|:-|=|' -e 's|:|=|' -e 's|^([^=]+)=?$|\1=?|'
}

#----------------------------------------------------------------------------------------------
# setup workspace if it does not exist
function deploy.initialize()
{
    # create WORKSPACE_DIR/docker-compose.yml
    deploy.updateDockerCompose 'createWsYaml'


    local json="$(lib.yamlToJson "$WORKSPACE_YAML")"
    [ $? -ne 0 ] && trap.die "Failed to parse $WORKSPACE_YAML"
    local -ri num_secrets=$(jq --compact-output --monochrome-output '.services[]|select(has("secrets"))|.secrets[]' <<< "$json" | wc -l)
    [ "$num_secrets" -eq 0 ] || deploy.populateSecrets "$SECRETS_DIR"


    # create the folders which are mounted by containers (defined in docker-compose volumes)
    local -A service_tasks=()
    for service_name in $(lib.yamlToJson "$WORKSPACE_YAML" | jq --compact-output --monochrome-output --raw-output '.services|keys[]?'); do

        # look for individual service tasks (to run later)
        local initFunction="${CONFIG_DIR}/${service_name}.setup"
        [ -e  "$initFunction" ] && service_tasks["$service_name"]="$initFunction"

        # get any defined volumes
        deploy.createVolumeFolders "$json" "$service_name"
    done


    # now run our service tasks
    for task in $(printf '%s\n' "${!service_tasks[@]}" | sort); do
        chmod a+rx "${service_tasks[$task]}"
        "${service_tasks[$task]}" ||:
    done

    # update secret references (cannot apply these with other docker-compose.yml updates)
    [ "$num_secrets" -eq 0 ] || deploy.updateSecretRefs "$WORKSPACE_YAML"
}

#----------------------------------------------------------------------------------------------
# used by '......setup' files
function deploy.isValidService()
{
    local -r service=${1:?}
    
    local result="$(lib.yamlToJson "$WORKSPACE_YAML" | jq --compact-output --monochrome-output --raw-output 'try .services|has("'"$service"'")' )"

    [ "${result:-}" != 'true' ] && return 1
    return 0
}
export -f deploy.isValidService

#----------------------------------------------------------------------------------------------
function deploy.main()
{
    # declare our GLOBAL variables
    declare -ax COMPLETION_MSG SKIP_WAIT
    declare -x CFG_EMAIL CFG_NAME CFG_USER CONFIG_DIR CONFIG_YAML CONTAINER_OS DEBUG_TRACE DEPLOY_YAML HOST_IP HOST_NAME LOG_DIR SECRETS_DIR START_TIMEWORKSPACE_DIR WORKSPACE_YAML 
    declare -A OPTS

    eval "OPTS=( ${1:?} )"
    readonly OPTS
    shift

    export DEBUG=${OPTS['debug']:-0}


    deploy.__initGlobals "${OPTS['base']}" "${OPTS['latest']:-}"

    [ -z "${OPTS['clean']:-}" ] || deploy.clean
    mkdir -p "$WORKSPACE_DIR" ||:


    if [ "${OPTS['init']:-}" ]; then
        #  initialize devops_container_environment
        term.log '$deploy.initialize 2>&1 | tee setup.log\n' 'grey'
        deploy.initialize 2>&1 | tee "${WORKSPACE_DIR}/setup.log"
        exit 0
    fi

    if [ "${OPTS['down']:-}" ] && [ -f "$WORKSPACE_YAML" ]; then
        # stop any running containers
        term.log '\nINFO: bringing down containers\n' 'white'
        term.log 'docker-compose --file '"$WORKSPACE_YAML"' down\n' 'grey'
        deploy.docker_compose down ||:
        exit 0
    fi


    versions.data "$DEPLOY_YAML" "${OPTS['latest']:-}"


    #  restart devops_container_environment  (performs configuration if needed)
    term.log '$deploy.restart 2>&1 | tee restart.log\n' 'grey'
    deploy.restart "${OPTS['latest']:-}" 2>&1 | tee "${WORKSPACE_DIR}/restart.log"
}

#----------------------------------------------------------------------------------------------
# used by '......setup' files
function deploy.passwordSecret()
{
    local -r service=${1:?}
    local -r pwdVar=${2:?}

    local secret jqQuery
    local -r json="$(lib.yamlToJson "$WORKSPACE_YAML")"
    local password="$(jq --compact-output --monochrome-output --raw-output '.services.'${service}'.environment.'${pwdVar} <<< "$json" )"
    if [ "$password" = 'null' ];then
        password="$(jq --compact-output --monochrome-output --raw-output '.services.'${service}'.environment.'${pwdVar}'_FILE' <<< "$json" )"
        secret="$(basename "$password")"
        jqQuery='.secrets."'"${secret}"'".file'
        local pwd_file="$(eval echo "$(jq --compact-output --monochrome-output --raw-output "$jqQuery" <<< "$json" )")"
        [ -e "$pwd_file" ] || trap.die "Password file: '$pwd_file' not found. Used by startup of service: $service"
        password=$(< "$pwd_file")
    fi
    echo "$password"
}
export -f deploy.passwordSecret

#----------------------------------------------------------------------------------------------
function deploy.populateSecrets()
{
    local -r secrets_dir=${1:-}

    if [ -d "$secrets_dir" ]; then
        # secrets_dir already exists. no need to populate
        :

    elif [ -z "${CFG_USER_SECRETS:-}" ]; then
        [ "${OPEN_SECRETS_REPO:-}" ] || trap.die  "no definition provided for 'secrets'"
        term.log 'populating '"$secrets_dir"' with user defined secrets\n'
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$OPEN_SECRETS_REPO" "$secrets_dir"

    elif [ -d "$CFG_USER_SECRETS" ] && [ "$(readlink -f "$CFG_USER_SECRETS")" != "$(readlink -f "$secrets_dir")" ]; then
        term.log 'populating '"$secrets_dir"' from local secrets dir\n'
        mkdir -p "$secrets_dir"
        cp -r "$CFG_USER_SECRETS"/* "$secrets_dir"/

    elif git.lsRemote "$CFG_USER_SECRETS" &> /dev/null ; then
        term.log 'populating '"$secrets_dir"' from git secrets\n'
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$CFG_USER_SECRETS" "$secrets_dir" --quiet
        if [ "$(grep -cs 'git-crypt' "${secrets_dir}/.gitattributes")" -gt 0 ]; then
            [ -e "${CRYPT_FILE:-}" ] || trap.die "secrets are encoded, but CRYPT_FILE: '${CRYPT_FILE:-}' does not exist"
            (cd "$secrets_dir"; git.cryptUnlock )
        fi

    else
        trap.die  "missing 'secrets' directory in WORKSPACE_DIR"
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.pushImages()
{
    local -r dc_yaml=${1:?}

    local -a images=()

    local -r json=$(lib.yamlToJson "$dc_yaml")

    # extract images from docker-compose
    
    local image
    while read -r image; do
        images+=( "$(eval "echo $image")" )
    done < <(jq --compact-output --monochrome-output --raw-output '.services[].image' <<< "$json")

    docker.pushRetained 1 "${images[@]}"
}

#----------------------------------------------------------------------------------------------
function deploy.refreshContainers()
{
    # make sure we start the correct versions
    if [ "${OPTS['dev']:-}" ]; then
        return 0
    elif [ "${OPTS['latest']:-}" = 'HEAD' ]; then
        term.log '\nINFO: updating containers to latest versions\n' 'white'
    else
        term.log '\n'"INFO: using container fingerprints defined in docker-compose.yml"'\n' 'white'
    fi
    term.log 'docker-compose --file '"$WORKSPACE_YAML"' pull\n' 'grey'
    deploy.docker_compose pull || return 1
}

#----------------------------------------------------------------------------------------------
function deploy.removeCBFlogs()
{
    while read -r dir; do
        [ -f "${dir}/cbf.log" ] || continue
        sudo rm "${dir}/cbf.log"
    done < <(find "$WORKSPACE_DIR" -mindepth 2 -maxdepth 2 -type d -name log)
}

#----------------------------------------------------------------------------------------------
function deploy.replaceIpAddresses()
{
    local -r filename=${1:?}
    local -r host_ip=${2:?}

    if [ -e "$filename" ]; then
        local expr='s|${HOST_IP}|'"${host_ip}"'|g'
        sudo sed -i -e "$expr" "$filename"
    fi
}
export -f deploy.replaceIpAddresses

#----------------------------------------------------------------------------------------------
function deploy.restart()
{
    local latest=${1:-}

    echo "CONTAINER_TAG: ${OPTS['container_tag']:-<using default>}" >&2

    # initialize workspace if required 'docker-compose.yml' is missing
    mkdir -p "$WORKSPACE_DIR" ||:
    cd "$WORKSPACE_DIR" ||:

    deploy.initialize
    deploy.removeCBFlogs

    # restart our environment
    deploy.restartContainers "$latest"

    local -r run_log="${WORKSPACE_DIR}/run.log"
    deploy.waitForInitializationComplete "$WORKSPACE_YAML" "$run_log"

    term.log '\nINFO: removing old containers\n' 'white'
    docker.clean

    docker.showProcessReport
    echo

    # show help at end of deploy
    [ "${INITIALIZE_COMPLETE:-}" ] && term.log 'Initializing complete.\n' 'white'
    if [ "${#COMPLETION_MSG[*]}" -gt 0 ]; then
        local msg
        for msg in "${COMPLETION_MSG[@]}"; do
            term.log "$(eval "echo $msg")"'\n' 'white'
        done
    fi
    exit 0
}

#----------------------------------------------------------------------------------------------
function deploy.restartContainers()
{
    local -r latest=${1:-}
    local -i status

    # stop any running containers
    term.log '\nINFO: bringing down containers\n' 'white'
    term.log 'docker-compose --file '"$WORKSPACE_YAML"' down\n' 'grey'
    deploy.docker_compose down ||:

    set -o verbose
    sudo find -L "$LOG_DIR" -type f ! -name '.*' -delete
    set +o verbose

    deploy.refreshContainers && status=$? || status=$?
    [ $status -eq 0 ] || return $status

    term.log '\nINFO: bringing up containers\n' 'white'
    term.log 'docker-compose --file '"$WORKSPACE_YAML"' up --detach\n' 'grey'
    # docker-compose v1.17.0 does not like '--detach'!
    deploy.docker_compose up -d  && status=$? || status=$?
    if [ $status -ne 0 ]; then
        term.log 'Failed to succussfully deploy container services.\n' 'white'
        exit 1
    fi

    # fixup docker-compose.yml to reflect the image versions in use
    if [ "${latest:-}" = 'HEAD' ]; then
        echo
        # Updating reference docker-compose.yml
        deploy.updateDockerCompose 'updateWsYaml'
        deploy.updateDockerCompose 'updateCfgYaml'
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.showInitializationBanner()
{
    term.log '******************************************************************************\n' 'white'
    term.log '*                                                                            *\n' 'white'
    term.log "*  initializing DevOps Container Environment on $(environ.ipAddress)"'\n'         'white'
    term.log '*                                                                            *\n' 'white'
    term.log '******************************************************************************\n' 'white'
    export INITIALIZE_COMPLETE='true'
}

#----------------------------------------------------------------------------------------------
function deploy.updateDockerCompose()
{
    local -r mode=${1:?}

    local dst_yaml json process src_yaml
    local -a args=()

    # setup the conditions to control how docker.compose gets updated
    case "$mode" in
        createWsYaml)
            # update docker-compose
            src_yaml="$CONFIG_YAML"
            dst_yaml="$WORKSPACE_YAML"
            process='deploy.fixupDCLineBeforeRun'
            ;;

        updateWsYaml)
            src_yaml="$CONFIG_YAML"
            dst_yaml="$WORKSPACE_YAML"
            process='deploy.fixupDCLineAfterRun'
            json=$(lib.yamlToJson "$dst_yaml")
            args=( '.newline' )
            ;;

        updateCfgYaml)
            src_yaml="$CONFIG_YAML"
            dst_yaml="$CONFIG_YAML"
            process='deploy.fixupDCLineAfterRun'
            json=$(lib.yamlToJson "$dst_yaml")
            args=( '.newline' 'isConfig' )
            ;;

        promote)
            src_yaml="$CONFIG_YAML"
            dst_yaml="$CONFIG_YAML"
            process='deploy.fixupDCLineAfterRun'
            json=$(lib.yamlToJson "$dst_yaml")
            args=( '.promoted' 'isConfig' )
            ;;

        production)
            src_yaml="$CONFIG_YAML"
            dst_yaml="$CONFIG_DIR/docker-compose.master.yml"
            process='deploy.fixupDCLineAfterRun'
            json=$(lib.yamlToJson "$WORKSPACE_YAML")
            args=( '.production' 'isConfig' )
            ;;

        *)
            trap.die "Invalid option passed to 'function ${FUNCNAME[0]}()'"
            ;;
    esac


    local -i status
    local -a services="$(lib.yamlToJson "$src_yaml" | jq --compact-output --monochrome-output --raw-output '.services|keys[]')"
    local tmp_file="${dst_yaml#.*}.tmp"
    (
        local service='null'
        local key=''
        while read -r line; do

            # skip blank lines
            if [ -z "${line:-}" ] || grep -sq '^\s+$' <<< "$line" ; then
                echo
                continue
            fi

            # look for 'service' definition  (capture start of line, to [:#], then look for key)
            key="$(sed -E -e 's|^(.+?[:#])\s.*$|\1|' <<< "$line" | sed -E -e 's|^\s+(\w+):\s*$|\1|')"
            if [ "${key:-}" ] && [ "${json:-}" ]; then

                # find service that defines image
                grep -qE '^\s+'"${key}"':\s*$' <<< "$line" && \
                    grep -q "$key" <<< "$services" && \
                    service=$(jq --compact-output --monochrome-output ".services.$key" <<< "$json")
            fi

            # process line
            if ! "$process" "$line" "$service" "${args[@]:-}"; then
                term.elog "Failed to process $line"'\n' 'warn'
                break
            fi
        done < "$src_yaml"
    ) > "$tmp_file"
    [ $? -ne 0 ] && trap.die "Failed to process file: $dst_yaml"

    # if there are no changes, delete tmp file
    if [ "$(lib.fileSha256 "$dst_yaml")" = "$(lib.fileSha256 "$tmp_file")" ]; then
        rm "$tmp_file"
        return 0   # no updates
    fi

    # otherwise rename 'src_yaml' to file.YYYYMMDDhhmmss.bak and rename updated file to 'dst_yaml'
    # create backup of dstfile before we update it
    term.log "INFO: updating ${dst_yaml}"'\n' 'white'
    if [ -f "$dst_yaml" ]; then
        local backup="${dst_yaml%.*}.$(date +"%Y%m%d%H%M%S").${dst_yaml##*.}.bak"
        backup="$(dirname "$backup")/~$(basename "$backup")"
        mv "$dst_yaml" "$backup"
    fi
    mv "$tmp_file" "$dst_yaml"   # file updated
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.updateSecretRefs()
{
    local -r dc_yaml=${1:?}
    sed -i -r -e 's|file:\s+~/|file: '"$(readlink -f ~)"'/|' "$dc_yaml"
}

#----------------------------------------------------------------------------------------------
function deploy.validateDockerComposeYaml()
{
    local -r dc_yaml=${1:?}
    [ $(jq --compact-output --monochrome-output '.services[].ports[]' <<< "$dc_yaml" | sort | wc -l) -eq $(jq --compact-output --monochrome-output '.services[].ports[]' <<< "$dc_yaml"| sort -u) ] || return 1
}

#----------------------------------------------------------------------------------------------
function deploy.verifyEnvironmentForFile()
{
    local -r file=${1:?}

    local var
    local -a unknown=()

    # scan file for BASH tokens of form: ${TOKEN} or ${TOKEN:-default} or ${TOKEN:?}
    while read -r var; do
        # ignore tokens which have a default value
        [ $(grep -c '?' <<< "$var") -ne 0 ] || continue

        var="${var%%=*}"                             # extract token
        [ "${var:-}" ] || continue                   # ignore if null
        [ -z "${!var:-}" ] && unknown+=( "$var" )    # add to 'unknown' unless TOKEN exists in our ENV
    done < <(deploy.getTokens "$file" | grep -Ev 'CONTAINER_TAG|DEV_TEAM' | sort -u ||: )

    if [ ${#unknown[*]} -gt 0 ]; then
        trap.die 'The following environment variables are undefined:'$(printf '\n    %s' "${unknown[@]}")
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.waitForInitializationComplete()
{
    local -r dc_yaml=${1:?}
    local -r run_log=${2:?}

    # get the list of containers we will be checking
    local -a containers
    mapfile -t containers < <(lib.yamlToJson "$dc_yaml" | jq --compact-output --monochrome-output --raw-output '.services|map(.container_name)|sort[]')

    # initialize the log
    echo "Started at: ${START_TIME}" > "$run_log"

    local -A finished=( )
    local -a lines=()
    local container line
    local -i index=1

    term.log '\n'"INFO: waiting for ${#containers[*]} containers to complete their startup"'\n' 'white'

    # check for containers that we skip
    for container in "${containers[@]}"; do
        [ "${container,,}" ] || continue                               # ignore invalid container
        [ "${finished[${container,,}]:-}" ] && continue                # ignore if we already have this result


        # ignore any that are not built with CBF (since they will not contain string we look for)
        local isCBFcontainer="$(docker inspect "${container,,}" | jq --compact-output --monochrome-output '.[].Config.Labels|has("container.git.url") and has("version.cbf")')"
        if [ "$isCBFcontainer" != 'true' ];then
            printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
            finished[$container]='0'
            SKIP_WAIT+=( "$container" )
            continue
        fi

        # ignore any that are defined in 'SKIP_WAIT'
        if [ "${#SKIP_WAIT[*]}" -gt 0 ] && [ $(printf '%s\n' "${SKIP_WAIT[@]}" | grep -cs "$container") -gt 0 ]; then
            printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
            finished[$container]='0'
            continue
        fi
    done

    while [ "${#finished[*]}" -lt "${#containers[*]}" ]; do
        # sleep 5 secs between scans
        sleep 5
        lines=()

        # check all known containers
        for container in "${containers[@]}"; do
            [ "${container,,}" ] || continue                               # ignore invalid container
            [ "${finished[${container,,}]:-}" ] && continue                # ignore if we already have this result

            # look for specific 'end of startup' string in logs
            local text="$(docker logs "${container,,}" 2>&1 | grep -s 'Finished executing startup' | head -1 ||: )"
            [ "$text" ] || continue                                        # ignore blank lines

            # keep track of what has finished
            lines+=( "$(sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$text" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }')_${container,,}" )
            [ "$(docker logs "${container,,}" 2>&1 | grep -sc '>>>>> issue while executing ' ||: )" -gt 0 ] && text='\e[93m'"$text"'\e[0m'
            finished[${container,,}]="$text"
        done

        # print out any containers we found in this scan
        [ "${#lines[*]}" -gt 0 ] || continue
        for line in $(printf '%s\n' "${lines[@]}" | sort -t '_' -k 1n,2); do   # sort by time taken to finish startup
            container="${line##*_}"                                            # extract container name
            container="${container,,}"
            printf '%02d. %b\n' $(( index++ )) "${finished[${container}]:-}"
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        done
    done


    # update the run.log from each 'docker logs'
    for container in "${containers[@]}"; do
       # if [ "${#SKIP_WAIT[*]}" -gt 0 ] && [ $(printf '%s\n' "${SKIP_WAIT[@]}" | grep -cs "$container") -gt 0 ]; then
          {
            echo 
            echo '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
            echo "${container}"
            echo
            docker logs "${container}" 2>&1                      # grab the log
          } >> "$run_log"
       # fi
    done
}

#----------------------------------------------------------------------------------------------
function deploy.workspace()
{
    local -r base_dir=${1:?}
    echo "${base_dir}/workspace.$(basename "$base_dir")"
}

#----------------------------------------------------------------------------------------------
#
#      MAIN
#
#----------------------------------------------------------------------------------------------

declare -i start=$(date '+%s')
declare -r PROGNAME="$( basename "${BASH_SOURCE[0]}" )"
declare -r PROGRAM_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"


declare -r loader="${PROGRAM_DIR}/appenv.bashlib"
if [ ! -e "$loader" ]; then
    echo 'Unable to load libraries' >&2
    exit 1
fi
source "$loader"
appenv.loader 'deploy.main'

lib.checkAppVersion 'docker-compose' '1.18.0'
#lib.checkAppVersion 'docker' '17.12.0'
#lib.checkAppVersion 'jq' '1.5'
#lib.checkAppVersion 'curl' '7.40.0'

declare -i status=0
declare -a args
args=( $( deploy.cmdLineArgs "$@" ) ) && status=$? || status=$?
[ $status -ne 0 ] || deploy.main "${args[@]:-}" && status=$? || status=$?

declare -i elapsed=$(( $(date '+%s') - start ))
[ $elapsed -gt 1 ] && printf '\nElapsed time: %s\n' $(timer.fmtElapsed $elapsed) >&2

exit $status 
