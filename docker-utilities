#!/bin/bash

declare -r grey='\e[90m'
declare -r white='\e[97m'
declare -r reset='\e[0m'
declare -A IMAGES_TO_DELETE=()
declare -A REPO_DIGESTS=()
declare REPORT_FORMAT='text'
declare REPORT_OUTPUT
declare -i DO_DELETE=0

declare MESSAGE=''
declare -i IS_DEBUG=${DEBUG:-0}
declare -i INCLUDE_FINGERPRINT=0
declare -i IS_QUIET=0
declare -i REPO_END=4294967295
declare -i REPO_KEEPTAGS=0
declare -i REPO_START=0
declare -i REPORTS_KEEP=0
declare -i MAX_IMAGES_TO_KEEP=10
declare -i TAG_ALLREPOS=0

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_general()
{
    local -r progname="${1:?}"
    cat >&2 << EOF

Various operations on the docker subsystem.

Usage:
    $progname [ help
              | clean
              | delete [ --max <numberOfImages> | --start startTime [ --end endTime ] [ --keepTags ] ] <regex>[:<regex>] <regex>[:<regex>] <regex>[:<regex>]
                       | image@digest
              | deteTag <regex>[:<regex>] [ --allRepos ]
                [ -q|--quiet ] [ -y|--confirm_delete ]
              | getremoteimage <imageName> <imageName> <imageName>
              | pushImage [ --fingerprint  ] <imageName> <imageName> <imageName>
              | rename <srcImageName> <dstImageName>
              | report [[ --catalog ] | [ --summary ] | [ --tags [<repoName>] ] | [ --tag-summary [<repoName>] ] | [ --format <text|json> ] [ --output <fileName> ]]
              | retagImages < newTag> [ <docker-compose.yml> ]
              | retagLatest [ <srcTag> [<newTag>] ]
              | show [ --images ] | [ --networks ] | [ --processes ] | [ --services ]

    Common options:
        -u --user <username>
        -c --credentials <credentials_file>   File container key/value pairs for user=pwd
        -q --quiet             Confirm action, otherwise do not delete anything
        -y --confirm_delete    Confirm action, otherwise do not delete anything

    Commands:
        help              Display a basic set of usage instructions
        clean             Clean docker environment by removing old images and stopped containers
        delete            Delete one or more images by specifying <regex>:<regex> - see 'usage examples'
              --keepTags    : delete a range of images in a repo by specifying "max # images" + keepTags
              --max         : delete a range of images in a repo by specifying "max # images"
              --start       : delete a range of images in a repo by specifying [start] <  > [end]
                            : delete images by specifying image@digest
        deleteTag         Delete one or more tags - see 'usage examples'
              --allRepos    : delete tag in all repos matching <regex>:tag
        getremoteimage    Get one or more images from some remote, and push to the default repository
        pushimage         Push a retained image
              --fingerprint : also push associated fingerprint if detected
        rename            Rename an image - locally and in $(registry.SERVER)
        report            Generate a report of contents of the registry
              --catalog     : show the registry catalog (as text)
              --format      : format output as JSON|TEXT
              --output      : name of file to output <filename>
              --keep        : 
              --tags        : show the tags associated with a repository (as text)
              --summary     : 
              --tag-summary : show a summary of tag usage for specified repos
        retagImages       Retag images defined in docker-compose.yml
        retagLatest       retag dev to defined tag (or 'latest' if no tag defined)
        show              common 'docker commands' with specific options to make more usefule
              --images      : docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" 
              --networks    : docker networks: also includes ip address and network name
              --processes   : docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}"
              --services    : show services defined in docker-compose.yml

    all registry references '$(registry.SERVER)' are automatically stripped from images and/or repos

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_clean()
{
    local -r progname="${1:?}"
    cat >&2 << EOF

    $progname clean

        remove old images and stopped containers then display a list of existing containers

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_delete()
{
    cat >&2 << EOF

    $progname delete [ --max <numberOfImages>
                     | --start startTime [ --end endTime ] [ --keepTags ] ] <regex>[:<regex>] [ <regex>[:<regex>] [ <regex>[:<regex>] [...]]]
                     | image@digest [ image@digest ] [ image@digest ]
                [ -q|--quiet ] [ -y|--confirm_delete ]

        Delete one or more images and/or repos by specifying <regex>:<regex>
              --keepTags    : delete a range of images in a repo by specifying "max # images" + keepTags
              --max         : delete a range of images in a repo by specifying "max # images"
              --start       : delete a range of images in a repo by specifying [start] <  > [end]
                            : delete images by specifying image@digest

    Common options:
        -q --quiet             Confirm action, otherwise do not delete anything
        -y --confirm_delete    Confirm action, otherwise do not delete anything


    examples:
            delete an image by specifying image@sha256:digest
            delete specific images across multiple repos by specifying <regex>:<regex>
              delete an image by specifying image:tag
              delete a range of images in a repo by specifying image:<regex>
              delete a repo by specifying image
              delete a repo by specifying image:*
              delete multiple repos by specifying <regex>
              delete images in all repos matching *:tag
            delete a range of images in a repo by specifying "max # images"
            delete a range of images in a repo by specifying "max # images" + keepTags
            delete a range of images in a repo by specifying [start]< createTime >[end]

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_deleteTagInSpecificRepo()
{
    cat >&2 << EOF

    $progname deleteTag <regex>[:<regex>] [ --allRepos ]

    delete Tag In Specific Repo
        delete one or more tags matching <regex>:tag from specifc repo
        when 'allRepos' is specified, tag(s) are deleted from all repos 

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_getImage()
{
    cat >&2 << EOF

    $progname getRemoteImage <imageName> [ <imageName> [ <imageName> [ ... ]]]

        getremoteimage    Get one or more images from some remote, and push to the default repository

    Note: 'getImage' is an alias for 'getRemoteImage'

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_pushImage()
{
    cat >&2 << EOF

    $progname pushImage [ --fingerprint  ] <imageName> [ <imageName> [ <imageName> [ ... ]]]
    
    push a retained image
       when 'fingerprint' is specified the  associated fingerprint tag (if detected) is pushed

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_rename()
{
    cat >&2 << EOF

    $progname rename <srcImage> <dstImage>
    
    rename an image
        Rename an image - locally and in $(registry.SERVER)

    examples:
            specify src_image and dst_image
            specify src_image<regex>, srcTag and dstTag on local system
            specify src_image<regex>, srcTag and dstTag in Registry
            specify src_image<regex>, srcTag and dstTag in both Registry and local system

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_report()
{
    cat >&2 << EOF

    $progname report [ [ <repoName> ] |
                            [ --catalog ] |
                            [ --summary ] | 
                            [ --tags [ <repoName> ] ] | 
                            [ --tag-summary [ <repoName> ] ] | 
                            [ --format <text|json> ] |
                            [ --output <fileName> ]]
              
    Generate a report of contents of the registry
              --catalog     : show the registry catalog (as text)
              --format      : format output as JSON|TEXT
              --output      : name of file to output <filename>
              --keep        : 
              --tags        : show the tags associated with a repository (as text)
              --summary     : 
              --tag-summary : show a summary of tag usage for specified repos

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_retagImages()
{
    cat >&2 << EOF

    $progname retagImages < newTag> [ <docker-compose.yml> ]

        Retag images defined in docker-compose.yml
    
EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_retagLatest()
{
    cat >&2 << EOF

    $progname retagLatest [ <srcTag> [<newTag>] ]
    
        retag dev to defined tag (or 'latest' if no tag defined)

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_show()
{
    cat >&2 << EOF

    $progname show [ --images ] | [ --networks ] | [ --processes ] | [ --services ]

        common 'docker commands' with specific options to make more usefule
              --images      : docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" 
              --networks    : docker networks: also includes ip address and network name
              --processes   : docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}"
              --services    : show services defined in docker-compose.yml

EOF
}

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
function docker-utilities.cmdLineArgs()
{
    local cmd=${1:-}
    shift

    local -A opts=(['cmd']='docker-utilities.usage')
    local longOpts=''
    local shortOpts=''
    local argsCondition

    case "${cmd,,}" in
        help|-h|--help)
            echo "['cmd']='docker-utilities.usage'"
            return 0;;

        -u|--user)
            [[ $# -eq 0 || $1 = -* ]] && trap.die 'invalid arguments!'
            opts['user']="$1"
            shift;;

        -c|--credentials)
            [[ $# -eq 0 || $1 = -* ]] && trap.die 'invalid arguments!'
            opts['credentials']="$1"
            shift;;

        clean)
            opts['cmd']='docker-utilities.clean'
            opts['check']='docker.isRunning'
            opts['message']="clean docker environment by removing old images and stopped containers"
            longOpts=''
            shortOpts=''
            argsCondition='$# -eq 0'
            ;;

        delete)
            opts['cmd']='docker-utilities.catalogIterator'
            opts['check']='docker.isRunning'
            opts['delete']=1
            opts['oper']='docker-utilities.delete'
            opts['message']="delete images in $(registry.SERVER) by specifying regex"
            longOpts='confirm_delete,end:,keepTags,max:,quiet,start:'
            shortOpts='e:km:qs:y'
            argsCondition='$# -ge 0'
            ;;

        deletetag)
            opts['cmd']='docker-utilities.deleteTagInSpecificRepo'
            opts['message']="delete specific tag from $(registry.SERVER)"
            longOpts='allRepos,quiet'
            shortOpts='aq'
            argsCondition='$# -eq 1'
            ;;

        getimage|getremoteimage)
            opts['cmd']='docker-utilities.getImage'
            opts['check']='docker.isRunning'
            opts['message']="Get one or more images from some remote, and push to $(registry.SERVER)thirdparty"
            longOpts='quiet'
            shortOpts='q'
            argsCondition='$# -eq 1'
            ;;

        pushimage)
            opts['cmd']='docker-utilities.pushImage'
            opts['check']='docker.isRunning'
            opts['message']="push images to $(registry.SERVER)"
            longOpts='fingerprint,quiet'
            shortOpts='fq'
            argsCondition='$# -eq 1'
            ;;

        rename)
            opts['cmd']='docker-utilities.renameImage'
            opts['check']='docker.isRunning'
            opts['message']="rename local images and push them to $(registry.SERVER)"
            longOpts='quiet'
            shortOpts='q'
            argsCondition='$# -eq 2'
            ;;

        report)
            opts['cmd']='docker-utilities.report'
            opts['message']="report remote images in $(registry.SERVER) "
            longOpts='catalog,format:,output:,quiet,summary,tag-summary,tags,keep'
            shortOpts='c:o:qstk'
            argsCondition='$# -ge 0'
            ;;

        retaglatest)
            opts['cmd']='docker-utilities.retagLatest'
            opts['check']='docker.isRunning'
            opts['message']="retag all 'dev' tagged imagges to 'latest' and push to $(registry.SERVER)"
            longOpts=''
            shortOpts=''
            argsCondition='$# -eq 1 || $# -eq 2'
            ;;

        retagimages)
            opts['cmd']='docker-utilities.retagImages'
            opts['check']='docker.isRunning'
            opts['message']="retag images defined in docker-compose.yml "
            longOpts=''
            shortOpts=''
            argsCondition='$# -eq 2'
            ;;

        show)
            opts['cmd']='docker-utilities.show'
            longOpts='images,networks,processes,services'
            shortOpts='inps'
            argsCondition='$# -ge 0'
            ;;

        *)
           trap.die "invalid command: $cmd" ;;
    esac


    # Parse command-line options
    local -r progname="$( basename "${BASH_SOURCE[0]}" )"
    longOpts='help,Help,HELP,user:,credentials:,'"$longOpts"
    shortOpts='hHc:u:'"$shortOpts"
    local -r options=$(getopt --longoptions "$longOpts" --options "$shortOpts" --name "$progname" -- "$@") || docker-utilities.usage '' $?
    eval set -- "$options"

    while true; do    
        case "${1,,}" in
            -h|--h|-help|--help)
                if [ "${opts['cmd']}" = 'docker-utilities.catalogIterator' ]; then
                    opts['oper']="${opts['oper']:17}"
                else
                    opts['oper']="${opts['cmd']:17}"
                fi
                opts['cmd']='docker-utilities.usage'
                opts['message']=''
                argsCondition='true'
                while [ $# -gt 0 ]; do
                    shift
                done
                break;;

            -a|-allrepos|--allrepos)
                opts['all']=1
                opts['cmd']='docker-utilities.catalogIterator'
                opts['oper']='docker-utilities.deleteTag'
                opts['message']="delete specific tag from all repos in $(registry.SERVER)"
                shift;;

            -c)
                if [[ $# -eq 0 || $2 = -* ]]; then
                    opts['oper']='catalog'
                    opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                    argsCondition='$# -eq 0'
                    shift
                else
                    opts['credentials']="$2"
                    shift 2
                fi;;

            -credentials|--credentials)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['credentials']="$1"
                shift 2;;

            -catalog|--catalog)
                opts['oper']='catalog'
                opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                argsCondition='$# -eq 0'
                shift;;

            -e|-end|--end)
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['end']="$(jq 'fromdate' '"'$2'"')"
                shift 2;;

            -f)
                if [[ "$longOpts" = *fingerprint* ]]; then
                    opts['fingerprint']=1
                    shift
                else
                    opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['format']="$2"
                    shift 2
                fi;;

            -fingerprint|--fingerprint)
                opts['fingerprint']=1
                shift;;

            -format|--format)
                opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['format']="$2"
                shift 2;;

            -i|-images|--images)
                opts['oper']='images'
                opts['message']="show details about local docker images  aka: <docker images> "
                shift;;

            -k)
                if [[ "$longOpts" = *summary* ]]; then
                    opts['keep']=1
                    shift
                else
                    opts['keepTags']=1
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags'
                    opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images and keepTags"
                fi;;

            -keep|--keep)
                opts['keep']=1
                shift;;

            -keeptags|--keeptags)
                opts['keepTags']=1
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags'
                opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images and keepTags"
                shift;;

            -m|-max|--max)
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImages'
                opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images"
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['max']="$2"
                shift 2;;

            -n|-networks|--networks)
                opts['oper']='networks'
                opts['message']='show details about current docker networks'
                shift;;

            -o|-output|--output)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['output']="$2"
                shift 2;;

            -p|-processes|--processes)
                opts['oper']='processes'
                opts['message']="show details about current processes   aka: <docker ps> "
                shift;;

            -q|-quiet|--quiet)
                opts['quiet']=1
                shift;;

            -s)
                if [[ "$longOpts" = *services* ]]; then
                    opts['oper']='summary'
                    opts['message']="generate a summary report for repos from $(registry.SERVER)"
                    argsCondition='$# -eq 0'
                    shift
                else
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                    opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['start']="$(jq 'fromdate' '"'$2'"')"
                    shift 2
                fi;;

            -services|--services)
                opts['oper']='services'
                opts['message']='show services defined in docker-compose.yml'
                shift;;

            -start|--start)
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['start']="$(jq 'fromdate' '"'$2'"')"
                shift 2;;

            -summary|--summary)
                opts['oper']='summary'
                opts['message']="generate a summary report for repos from $(registry.SERVER)"
                argsCondition='$# -eq 0'
                shift;;

            -t|-tags|--tags)
                opts['oper']='tags'
                opts['message']="generate a summary report of the tags used by repos from $(registry.SERVER)"
                argsCondition='$# -eq 1'
                shift;;

            -tag-summary|--tag-summary)
                opts['oper']='tag-summary'
                opts['message']="generate a summary report of the tags used by repos from $(registry.SERVER)"
                argsCondition='$# -eq 1'
                shift;;

            -u|--user)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['user']="$2"
                shift 2;;

            -y|-confirm_delete|--confirm_delete)
                opts['do_delete']=1
                shift;;

            --)
                shift
                break;;

            *)
                break;;

        esac
    done

    if [ ${IS_DEBUG:-0} -gt 0 ]; then
        for i in "${!opts[@]}"; do
           printf '%s: %s\n' $i "${opts[$i]}" >&2
        done
        for i in "$@"; do
           printf ' %s\n' "$i" >&2
        done
    fi

    $(eval "[[ $argsCondition ]]") || trap.die 'invalid arguments!'

    appenv.results $(docker-utilities.removeRegistryReference "$@")
    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.addImageToList()
{
    local -r name=${1:?}
    local -r tags=${2:?}

    if [ "${IMAGES_TO_DELETE[$name]:-}" ]; then
        IMAGES_TO_DELETE[$name]+=( "$tags" )
    else
        IMAGES_TO_DELETE[$name]="$tags"
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.catalogIterator()
{
    local fn=${1:?}
    shift

    local -i status=0
    local -i content=0
    local catalog id name repo tag
    local -a repos catalog

    local -a requests=( "$@" )
    [ "${#requests[*]}" -gt 0 ] || requests=( '.+' )


    catalog="$(docker-utilities.filterCatalog "$@")" # ignore errors
    echo >&2

    for name in "${requests[@]}"; do
        if [[ "$name" = *@sha256:* ]]; then
           repo="${name%@*}"
           tag="${name##*@}"

        elif [[ "$name" = *:* ]]; then
            repo="${name%:*}"
            tag="${name##*:}"

        else
            repo="$name"
            tag='^.*$'
        fi

        mapfile -t repos < <(grep -Es '^'"$repo"'$' <<< "$catalog" ||:)
        [ "${#repos[*]}" -gt 0 ] || continue
        (( content++ )) ||:

        for repo in "${repos[@]}"; do
            "$fn" "$repo" "$tag" || status=1
            [ $TAG_ALLREPOS -ne 0 ] && continue
            [ $status -ne 0 ] && break 2
        done
    done

    [ $content -eq 0 ] && term.elog '\nNo content specified\n' 'warn'
    return $status
}

#----------------------------------------------------------------------------------------------
#   clean: remove Old Containers and '<none>' images 
function docker-utilities.clean()
{
    docker.clean
    docker-utilities.show 'images' "$@"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.confirmImageDeletion()
{
    if [ "${#IMAGES_TO_DELETE[*]}" -eq 0 ]; then
        term.elog 'No images to delete\n' 'warn'
        return 0
    fi

    local image name digest repo yesno
    local -i status=0
    local -a tags

    term.elog '\nAbout to delete the following '${#IMAGES_TO_DELETE[*]}' images:      <repo_name>@<digest> : <tags>\n'
    for image in "${!IMAGES_TO_DELETE[@]}"; do
        local -a tags=( ${IMAGES_TO_DELETE[$image]} )
        printf '    %s : %s\n' "$image" "$tags" | sort >&2
    done
    echo >&2

    local prompt='[Yes/No/All/Quit]'
    [ "${#IMAGES_TO_DELETE[*]}" -eq 1 ] && prompt='[Yes/No]'
    for image in "${!IMAGES_TO_DELETE[@]}"; do
        repo="${image%@*}"
	digest="${image##*@}"

        if [ "${DO_DELETE:-0}" -eq 0 ]; then
            echo -en "Delete $image $prompt ? " >&2
            local yesno='n'
            read yesno
            echo >&2
            yesno="${yesno,,}"
            [ "${yesno:0:1}" = 'n' ] && status=1 && continue
            [ "${yesno:0:1}" = 'q' ] && status=2 && break
            [ "${yesno:0:1}" = 'a' ] && DO_DELETE=1
        fi
        registry.deleteImage "$repo" "$digest" || status=$?
    done
    echo >&2
    IMAGES_TO_DELETE=()
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.delete()
{
    local -r image=${1:?}
    local -r tag=${2:?}

    local digest
    local -A digests


    eval "digests=( $(docker-utilities.digests "$image" 'notimes' | jq -r '.[]|.tags|=join(",")|"[\(.digest)]=\(.tags)"') )"
    [ "${#digests[*]}" -le 0 ] && return 0

    for digest in "${!digests[@]}"; do
        grep -Esq '^'"$tag"'$' <<< ${digests[$digest]} && docker-utilities.addImageToList "${image}@$digest" "${digests[$digest]}"
    done
    return 0
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying "max # images"
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImages()
{
    local -r image=${1:?}
    local -r tag=${2:?}

    local -r name="${image%:*}"
    local json="$(docker-utilities.digests "$name" )"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${name} - does not exist"

    local -i status=0
    local -ir imageCount=$(jq 'length' <<< "$json")
    if [ $imageCount -ge $MAX_IMAGES_TO_KEEP ]; then
        local -ir delta=$(( imageCount - MAX_IMAGES_TO_KEEP + 1 ))
        [ $delta -le 1 ] || term.log "    repo ${name} contains ${delta} images over recommended limit"'\n' 'lt_yellow'
        json=$(jq -r "sort_by(.createTime|fromdate)[0:${delta}]" <<< "$json")

        local -i idx
        local digest image_json tags
        for (( idx=0; idx < delta; idx++ )); do
            image_json="$(jq '.['$idx']' <<< "$json")"
            digest=$(jq -r '.digest' <<< "$image_json")
            tags=$(jq -r '.tags|join(",")' <<< "$image_json")
            docker-utilities.addImageToList "${name}@$digest" "$tags" || status=1
        done
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying "max # images" + keepTags
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags()
{
    local -r image=${1:?}
    local -r tag=${2:?}

    local -r name="${image%:*}"
    local json="$(docker-utilities.digests "$name" )"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${name} - does not exist"

    local -i status=0
    local -ir imageCount=$(jq '[.[]|select((.tags|length) == 1)]|length' <<< "$json")
    if [ $imageCount -ge $MAX_IMAGES_TO_KEEP ]; then
        local -ir delta=$(( imageCount - MAX_IMAGES_TO_KEEP + 1 ))
        [ $delta -le 1 ] || term.log "    repo ${name} contains ${delta} images over recommended limit"'\n' 'lt_yellow'
        json=$(jq -r "[.[]|select((.tags|length) == 1)]|sort_by(.createTime|fromdate)[0:${delta}]" <<< "$json")

        local -i idx
        local digest image_json tags
        for (( idx=0; idx < delta; idx++ )); do
            image_json="$(jq '.['$idx']' <<< "$json")"
            digest=$(jq -r '.digest' <<< "$image_json")
            tags=$(jq -r '.tags|join(",")' <<< "$image_json")
            docker-utilities.addImageToList "${name}@$digest" "$tags" || status=1
        done
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying [start] <=|<|>|>= [end]
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime()
{
    local -r image=${1:?}

    local -r name="${image%:*}"
    local json="$(docker-utilities.digests "$name")"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${name} - does not exist"

    json=$(jq -r "sort_by(.createTime|fromdate)" <<< "$json")
    local -ir imageCount=$(jq 'length' <<< "$json")

    local -i createTime
    local -i idx
    local digest image_json tags

    local -i status=0
    for (( idx=0; idx < imageCount; idx++ )); do
        image_json="$(jq '.['$idx']' <<< "$json")"
        createTime=$(jq -r '.createTime|fromdate' <<< "$image_json")
        [ "$createTime" -gt "${REPO_START:-}" ] && [ "$createTime" -lt "${REPO_END:-}"  ] && continue

        digest=$(jq -r '.digest' <<< "$image_json")
        tags=$(jq -r '.tags|join(",")' <<< "$image_json")
        docker-utilities.addImageToList "${name}@$digest" "$tags" || status=1
    done
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting repos : delete a repo by specifying image:*
function docker-utilities.deleteTagInSpecificRepo()
{
    local -r name=${1:?}

    local repo tag
    if [[ "$name" = *:* ]]; then
        repo="${name%:*}"
        tag="${name##*:}"
    else
        repo='*'
        tag="$name"
    fi

    if [ "$repo" = '*' ]; then
        TAG_ALLREPOS=1
        docker-utilities.catalogIterator 'docker-utilities.deleteTag' "${repo}:$tag"
    else
        docker-utilities.deleteTag "$repo" "$tag"
    fi
}

#----------------------------------------------------------------------------------------------
# deleting repos : delete a repo by specifying image:*
function docker-utilities.deleteTag()
{
    local -r repo=${1:?}
    local -r tag=${2:?}

    local -r json="$(docker-utilities.digests "$repo" 'notimes' | jq -c '.[]|select(.tags|any(test("'$tag'")))')"

    local -a tags
    mapfile -t tags < <(jq -r '.tags[]' <<< "${json}" )
    if [ "${#tags[*]}" -eq 0 ]; then
        [ $TAG_ALLREPOS -ne 0 ] && return 0
        trap.die "repository: ${repo} - does not exist"
    fi
    tags=( $(printf '%s\n' "${tags[@]}" | grep -v "$tag") )

    local -i status
    if [ "${#tags[*]}" -eq 0 ]; then
        # remove image since it only has single tag
        docker-utilities.addImageToList "${repo}@$(jq -r '.digest' <<< "$json")"  $tag
        docker-utilities.confirmImageDeletion || trap.die "failed to remove image: ${repo}:$tag"
        return 0
    fi

    local -r image="${repo}:${tag}"
    # pull a copy of image so we can restore other tags
    local -i pulledImageExists=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -cH "$(registry.SERVER)$image" | cut -d ':' -f 2 ||:)
    [ "$pulledImageExists" -gt 0 ] || docker-utilities.run docker pull "$(registry.SERVER)$image"


    # remove image (and all associated tags)
    docker-utilities.addImageToList "${repo}@$(jq -r '.digest' <<< "$json")" $tag
    docker-utilities.confirmImageDeletion || trap.die "failed to remove image: $image"


    # push image back using remaining tags
    for tg in "${tags[@]}"; do
        echo "pushing $(registry.SERVER)${repo}:$tg" >&2
        docker-utilities.run docker tag "$(registry.SERVER)$image" "$(registry.SERVER)${repo}:$tg"
        docker-utilities.run docker push "$(registry.SERVER)${repo}:$tg"
        docker-utilities.run docker rmi "$(registry.SERVER)${repo}:$tg"
    done

    # remove local copy of image if it wasn't originaly local
    [ "$pulledImageExists" -gt 0 ] || docker-utilities.run docker rmi "$(registry.SERVER)$image"

    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.digests()
{
    local -r repo=${1:?}
    local -r notimes=${2:-}

    if [ -z "${REPO_DIGESTS[$repo]:-}" ]; then
        [ $IS_QUIET -eq 0 ] && term.elog "retrieving digests for $repo"'\n' 'grey'
        REPO_DIGESTS[$repo]="[$(registry.digests "$repo" $notimes)]"
    fi
    echo ${REPO_DIGESTS[$repo]}
}

#----------------------------------------------------------------------------------------------
function docker-utilities.filterCatalog()
{
    local image
    local -a catalog=()
    for image in "$@"; do
        catalog+=( "${image%:*}" )
    done

    [ "${#catalog[*]}" -gt 0 ] || catalog=( '.+' )

    local tmpfile="$(mktemp)"
    printf '%s\n' "${catalog[@]}" > "$tmpfile"

    registry.catalog | grep -E -f "$tmpfile" ||: # ignore errors
    rm "$tmpfile"
    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.getImage()
{
    local -r image=${1:?}

    local -i status=0


    if [ -z "$(docker image ls -q $image)" ]; then
        docker pull "$image" || status=$?
        [ $status -ne 0 ] && return $status
    fi

    docker tag "$image" "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -eq 0 ] && docker push "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -ne 0 ] && return $status

    docker rmi "$image" || status=$?
    docker rmi "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -ne 0 ] && term.elog 'WARNING:  Failed to cleanup temporary images' 'warn'

    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.main()
{
    local -A opts
    eval "opts=( $1 )"
    readonly opts
    shift

    if [ "${opts['check']:-}" ]; then
        "${opts['check']}" || trap.die 'Docker is not running'
    fi
    [ "${opts['do_delete']:-}" ] &&   DO_DELETE=1
    [ "${opts['fingerprint']:-}" ] && INCLUDE_FINGERPRINT=1
    [ "${opts['quiet']:-}" ] &&       IS_QUIET=1
    [ "${opts['max']:-}" ] &&         MAX_IMAGES_TO_KEEP=${opts['max']}
    [ "${opts['keep']:-}" ] &&        REPORTS_KEEP=1
    [ "${opts['format']:-}" ] &&      REPORT_FORMAT=${opts['format']}
    [ "${opts['output']:-}" ] &&      REPORT_OUTPUT="${opts['output']}"
    [ "${opts['end']:-}" ] &&         REPO_END=${opts['end']}
    [ "${opts['keepTags']:-}" ] &&    REPO_KEEPTAGS=1
    [ "${opts['start']:-}" ] &&       REPO_START=${opts['start']}
    [ "${opts['all']:-}" ] &&         TAG_ALLREPOS=1

    if [ "${opts['user']:-}" ]; then
        USERNAME="${opts['user']}"
        USER="${opts['user']}"
    fi
    [ "${opts['credentials']:-}" ] && __SECRETS_FILE="${opts['credentials']}"


    [ -z "${opts['message']:-}" ] || term.elog "${opts['message']} : $*"'\n' 'grey'
    local status=0
    DEBUG=1

#    echo "cmd: ${opts['cmd']}" >&2
#    echo "oper: ${opts['oper']}" >&2
    "${opts['cmd']}" ${opts['oper']:-} "$@" && status=$? || status=$?
    if [ $status -eq 0 ] && [ "${opts['delete']:-}" ]; then
         docker-utilities.confirmImageDeletion && status=$? || status=$?
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
# push images to $(registry.SERVER)
function docker-utilities.pushImage()
{
    local -i status=0

    local image
    local -a images=()
    for image in "$@"; do
        [ "${image:-}" ] && images+=( $(registry.SERVER)$image )
    done
    docker.pushRetained $INCLUDE_FINGERPRINT "${images[@]}" && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.removeRegistryReference()
{
    for id in "$@"; do
        [ "${id:-}" ] && echo ${id#$(registry.SERVER)}
    done
}

#----------------------------------------------------------------------------------------------
# rename image : specify src_image and dst_image
function docker-utilities.renameImage()
{
    local src=${1:?}
    local dst=${2:?}
    term.elog "rename local images and push them to $(registry.SERVER) : $*"'\n' 'grey'

    local srcName="${src%:*}"
    local srcTag="${src##*:}"
    [ "${srcName:-}" ] && [ "${srcTag:-}" ] || trap.die "Invalid $src specified"

    local dstName="${dst%:*}"
    local dstTag="${dst##*:}"

    [ "${dstTag:-}" ] || dstTag="$srcTag"
    [ "${dstName:-}" ] && [ "$dstName" != "$dstTag" ] || $dstName="$srcName"
    [ "$srcName" != "$dstName" ] || [ "$srcTag" != "$dstTag" ] || trap.die "$src & $dst specify same image"

    local exists=$(docker image ls --quiet "$(registry.SERVER)$src")
    [ "${exists:-}" ] || docker-utilities.run docker pull "$(registry.SERVER)$src"
    docker-utilities.run docker tag "$(registry.SERVER)$src" "$(registry.SERVER)${dstName}:$dstTag"
    docker.pushRetained 0 "$(registry.SERVER)${dstName}:$dstTag"
    [ "${exists:-}" ] || docker-utilities.run docker rmi "$(registry.SERVER)$src"
    docker-utilities.deleteTag "$srcName" "$srcTag"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.report()
{
    local reportType=${1:-}
    shift
    local -i status

    case "${reportType:-}" in
        catalog)
            registry.catalog && status=$? || status=$?
            ;;

        tags)
            registry.tags "$@" && status=$? || status=$?
            ;;

        tag-summary)
            docker-utilities.reportTagSummary "$@" && status=$? || status=$?
            ;;

        *)
            if [ -z "${REPORT_OUTPUT:-}" ] && [ "${REPORT_FORMAT:-}" = 'json' ]; then
                docker-utilities.reportCatalogAsJson "${reportType:-}" "$@"  && status=$? || status=$?

            else
                local report_json="/tmp/reportCatalog.$$.json"
                [ "${REPORT_FORMAT:-}" = 'json' ] && report_json="$REPORT_OUTPUT"
                readonly report_json

                {
                    docker-utilities.reportCatalogAsJson "${reportType:-}" "$@" && status=$? || status=$?
                }  > "$report_json"

                if [ $status -eq 0 ] && [ "${REPORT_FORMAT:-}" != 'json' ]; then
            
                    docker-utilities.reportTextFormat "$report_json" && status=$? || status=$?

                    if [ $status -eq 0 ]; then
                        [ $REPORTS_KEEP -ne 0 ] && return 0
                        for report in summary.txt reportDetails.txt reportList.txt; do
                            report="$(pwd)/$report"
                            case "${REPORT_OUTPUT:-}" in
                                *.txt)
                                    cat "$report" > "$REPORT_OUTPUT"
                                    ;;
                                *)
                                    cat "$report"
                                    ;;
                            esac
                            rm "$report"
                        done
                    fi
                    [ ! -e "$report_json" ] || rm "$report_json"
                fi
            fi
        esac
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.reportCatalogAsJson()
{
    local -a catalog
    mapfile -t catalog < <(docker-utilities.filterCatalog "$@") # ignore errors
#ssh ubuntu-s2 df /dev/sdb1 | tail -1 | awk '{print $5 " used, " $3/1024/1024 " GB  available"}' > storage.txt

    if [ "${#catalog[*]}" -gt 0 ]; then
        echo -n '['
        local -i index=0
        for entry in "${catalog[@]}"; do
            (( index++ )) && echo -n ','

            local digests="$(registry.digests "$entry")"
            printf '{"id":"%05d","repository":"%s"' "$index" "$entry"
            [ -z "$digests" ] || echo -n ',"digests":['"${digests}"']'
            echo -n '}'
        done
        echo -n ']'
    else
        term.elog '\nNo content specified\n' 'warn'
    fi
}


#----------------------------------------------------------------------------------------------
function docker-utilities.reportTagSummary()
{
    local -a catalog
    mapfile -t catalog < <(docker-utilities.filterCatalog "$@") # ignore errors
    if [ "${#catalog[*]}" -gt 0 ]; then
        local -i fingerprints=0
        local -i digests=0
        local -A tags=()
        local json name tag

        for name in "${catalog[@]}"; do
            json="$(docker-utilities.digests "$name" 'notimes')"
            [ "${#json}" -gt 0 ] || continue
            (( digests+=$(jq -r '.|length' <<< "$json") )) ||:
            for tag in $(jq -r '.[].tags[]' <<< "$json"); do
                if [ "${#tag}" -eq 64 ]; then
                    (( fingerprints++ )) ||:
                elif [ -z "${tags[$tag]:-}" ]; then
                    tags[$tag]=1
                else
                    (( tags[$tag]++ )) ||:
                fi
            done
        done

        (
            [ "$digests" -gt 0 ] && echo "detected ${digests} image digests"
            [ "$fingerprints" -gt 0 ] && echo "detected ${fingerprints} fingerprints"
            if [ "${#tags[*]}" -gt 0 ]; then
                echo 'detected the following tags'
                for tag in "${!tags[@]}"; do
                    printf '    %s  : %d\n' "$tag"  "${tags[$tag]}"
                done
            fi
        ) >&2
    else
        term.elog '\nNo content specified\n' 'warn'
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.reportTextFormat()
{
    local -r report_json=${1:?}
    local -i status

    docker run --rm \
               --volume "$PROGRAM_DIR":/usr/share/bin \
               --volume "/tmp:/tmp" \
               --volume "$(pwd):/home/groovy/scripts" \
               --user "$(id --user):$(id --group)" \
               -e "JSON=$report_json" \
               --workdir /home/groovy/scripts \
               "$(registry.SERVER)thirdparty/groovy:2.6-jre-alpine" \
               groovy /usr/share/bin/registryReport.groovy \
               && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
# retag images
function docker-utilities.retagImages()
{
    local to=${1:?'"to" tag must be specified'}
    local yaml=${2:-docker-compose.yml}

    [ ! -e "$yaml" ] && trap.die "Unable to locate $yaml"'\n'

    local -a images
    mapfile -f images < <(docker.yamlToJson "$yaml" | jq -r '.services[].image')
    if [ "${#images[*]}" -gt 0 ]; then
        local image target
        for image in "${images[@]}"; do
            image=$(eval echo $image)
            target="${image%:*}:$to"
            docker tag "$image" "$target"
            docker rmi "$image" || :
        done
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.retagLatest()
{
    local from="${1:?}"
    local to="${2:-latest}"

    local image target
    local -a images=()
    while read -r image; do
        target="${image%:*}:$to"
        images+=( "$target" )
        docker tag "$image" "$target"
    done < <(docker images --format '{{.Repository}}:{{.Tag}}' | grep "$from")

    INCLUDE_FINGERPRINT=1
    docker-utilities.pushImage $(docker-utilities.removeRegistryReference "${images[@]}")
    docker rmi "${images[@]}"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.run()
{
    [ $DEBUG -ne 0 ] && (echo -e "${grey}$(printf '%s ' "$@")$reset" >&2)
    eval $@ > /dev/null
}

#----------------------------------------------------------------------------------------------
function docker-utilities.show()
{
    local -r mode=${1:?}
    local filter=${2:-}
    
    local -i status=0
    case "$mode" in
        images)
            # show image report
            local -a images
            echo
            mapfile -t images < <(docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}")
            if [ ${#images[*]} -gt 1 ]; then
                echo -e "\e[97m${images[0]}\e[0m" >&2
                unset images[0]
                if [ "${filter:-}" ]; then
                    [[ $filter == *:* ]] && filter=$(sed -e 's|:|\\s+|' <<< "$filter")                
                    (printf '%s\n' "${images[@]}" | sort | grep -E "$filter") && status=$? || status=$?
                else
                    printf '%s\n' "${images[@]}" | sort && status=$? || status=$?
                fi
                echo
            fi
            ;;

        networks)
            # show networks
            local -a hosts
            local -a networks
            mapfile -t networks < <(docker network ls)
            if [ ${#networks[*]} -gt 1 ]; then
                echo -e "\e[97m${networks[0]}\e[0m" >&2
                unset "networks[0]"
                for network in "${networks[@]}"; do
                    echo $network
                    mapfile -t hosts < <(docker network inspect "$(cut -d ' ' -f 1 <<< "$network")" | \
                                         jq -r ".[].Containers|.[]|[.IPv4Address + \" : \" + .Name]|.[]" | \
                                         sort -t "." -k 4g) && status=$? || status=$?
                    [ "${#hosts[*]}" -gt 0 ] || continue
                    printf '    %s\n' "${hosts[@]}"
                done
            fi
            ;;

        processes)
            # show processes
            local -a containers
            echo
            mapfile -t containers < <(docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}")
            if [ ${#containers[*]} -gt 1 ]; then
                echo -e "\e[97m${containers[0]}\e[0m" >&2
                unset "containers[0]"
                if [ "${filter:-}" ]; then
                    (printf '%s\n' "${containers[@]}" | sort | grep -E "$filter") && status=$? || status=$?
                else
                    printf '%s\n' "${containers[@]}" | sort && status=$? || status=$?
                fi
            fi
            ;;

        services)
            # show docker-compose services
            local yaml=${2:-docker-compose.yml}
            [ ! -e "$yaml" ] && trap.die "Unable to locate $yaml"'\n'

            local jsonConfig=$(docker.yamlToJson "$yaml" | jq -c '.services?')
            [ -z "${jsonConfig:-}" ] && trap.die echo "Invalid file: $yaml"'\n'
            jq -r 'keys[]?' <<< "$jsonConfig" && status=$? || status=$?
            ;;
    esac
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.usage()
{
    local -r context="${1:-help}"
    local -ir exit_status="${2:-127}"
    local -r progname="$( basename "${BASH_SOURCE[0]}" )"

    case "$context" in
        clean)
            docker-utilities.helpFor_clean "$progname"
            ;;
        delete)
            docker-utilities.helpFor_delete "$progname"
            ;;
        deleteTagInSpecificRepo)
            docker-utilities.helpFor_deleteTagInSpecificRepo "$progname"
            ;;
        getImage)
            docker-utilities.helpFor_getImage "$progname"
            ;;
        pushImage)
            docker-utilities.helpFor_pushImage "$progname"
            ;;
        renameImage)
            docker-utilities.helpFor_rename "$progname"
            ;;
        report)
            docker-utilities.helpFor_report "$progname"
            ;;
        retagLatest)
            docker-utilities.helpFor_retagLatest "$progname"
            ;;
        retagImages)
            docker-utilities.helpFor_retagImages "$progname"
            ;;
        show)
            docker-utilities.helpFor_show "$progname"
            ;;
        *)
            docker-utilities.helpFor_general "$progname"
            ;;
    esac
    exit "$exit_status"
}

#----------------------------------------------------------------------------------------------
#
#      MAIN
#
#----------------------------------------------------------------------------------------------

declare -i status
declare -a args
declare -i DEBUG

declare -r PROGRAM_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
declare -r loader="$PROGRAM_DIR/appenv.bashlib"
if [ ! -e "$loader" ]; then
    echo 'Unable to load libraries'
    exit 1
fi
source "$loader"

appenv.loader 'docker-utilities.main'
args=( $( docker-utilities.cmdLineArgs "$@" ) ) && status=$? || status=$?
[ $status -eq 0 ] && docker-utilities.main "${args[@]}" && status=$? || status=$?
exit $status
