#!/bin/bash

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_general()
{
    cat >&2 << EOF

Various operations on the docker subsystem.

Usage:
    $PROGNAME [ help
              | clean
              | delete [ --max <numberOfImages> | --start startTime [ --end endTime ] [ --keepTags ] ] <regex>[:<regex>] <regex>[:<regex>] <regex>[:<regex>]
                       | image@digest
              | deteTag <regex>[:<regex>]
                [ -q|--quiet ] [ -y|--no_confirm_delete ]
              | getRemoteImage <imageName> <imageName> <imageName>
              | pushImage [ --fingerprint  ] <imageName> <imageName> <imageName>
              | rename <srcImageName> <dstImageName>
              | report [[ --catalog ] | [ --summary ] | [ --tags [<repoName>] ] | [ --tag-summary [<repoName>] ] | [ --format <text|json> ] [ --output <fileName> ]]
              | retagImages < newTag> [ <docker-compose.yml> ]
              | retagLatest [ <srcTag> [<newTag>] ]
              | updateImage <imageName> <imageName> <imageName>
              | show [ --images ] | [ --networks ] | [ --processes ] | [ --services ]

    Common options:
        -u --user <username>                  Defaults to \${USERNAME:-\$USER}                  
        -c --credentials <credentials_file>   File container key/value pairs for user=pwd
        -q --quiet                            Confirm action, otherwise do not delete anything
        -y --no_confirm_delete                Confirm action, otherwise do not delete anything

    Commands:
        help              Display a basic set of usage instructions
        clean             Clean docker environment by removing old images and stopped containers
        delete            Delete one or more images by specifying <regex>:<regex> - see 'usage examples'
              --keepTags    : delete a range of images in a repo by specifying "max # images" + keepTags
              --max         : delete a range of images in a repo by specifying "max # images"
              --start       : delete a range of images in a repo by specifying [start] <  > [end]
                            : delete images by specifying image@digest
        deleteTag         Delete one or more tags - see 'usage examples'
        getRemoteImage    Get one or more images from some remote, and push to the default repository
        pushimage         Push a retained image
              --fingerprint : also push associated fingerprint if detected
        rename            Rename an image - locally and in $(registry.SERVER)
        report            Generate a report of contents of the registry
              --catalog     : show the registry catalog (as text)
              --format      : format output as JSON|TEXT
              --output      : name of file to output <filename>
              --keep        : 
              --tags        : show the tags associated with a repository (as text)
              --summary     : 
              --tag-summary : show a summary of tag usage for specified repos
        retagImages       Retag images defined in docker-compose.yml
        retagLatest       retag dev to defined tag (or 'latest' if no tag defined)
        show              common 'docker commands' with specific options to make more usefule
              --images      : docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" 
              --networks    : docker networks: also includes ip address and network name
              --processes   : docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}"
              --services    : show services defined in docker-compose.yml
        updateRemoteImage 'GetRemoteImage' and update GIT repo

    all registry references '$(registry.SERVER)' are automatically stripped from images and/or repos

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_clean()
{
    cat >&2 << EOF

    $PROGNAME clean

        remove old images and stopped containers then display a list of existing containers

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_delete()
{
    cat >&2 << EOF

    $PROGNAME delete [ --max <numberOfImages>
                     | --start startTime [ --end endTime ] [ --keepTags ] ] <regex>[:<regex>] [ <regex>[:<regex>] [ <regex>[:<regex>] [...]]]
                     | image@digest [ image@digest ] [ image@digest ]
                [ -q|--quiet ] [ -y|--no_confirm_delete ]

        Delete one or more images and/or repos by specifying <regex>:<regex>
              --keepTags    : delete a range of images in a repo by specifying "max # images" + keepTags
              --max         : delete a range of images in a repo by specifying "max # images"
              --start       : delete a range of images in a repo by specifying [start] <  > [end]
                            : delete images by specifying image@digest

    Common options:
        -u --user <username>                  Defaults to \${USERNAME:-\$USER}                  
        -c --credentials <credentials_file>   File container key/value pairs for user=pwd
        -q --quiet              Confirm action, otherwise do not delete anything
        -y --no_confirm_delete  Confirm action, otherwise do not delete anything


    examples:
            delete an image by specifying image@sha256:digest
            delete specific images across multiple repos by specifying <regex>:<regex>
              delete an image by specifying image:tag
              delete a range of images in a repo by specifying image:<regex>
              delete a repo by specifying image
              delete a repo by specifying image:*
              delete multiple repos by specifying <regex>
              delete images in all repos matching *:tag
            delete a range of images in a repo by specifying "max # images"
            delete a range of images in a repo by specifying "max # images" + keepTags
            delete a range of images in a repo by specifying [start]< createTime >[end]

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_deleteTagInSpecificRepo()
{
    cat >&2 << EOF

    $PROGNAME deleteTag <regex>[:<regex>]

    delete Tag In Specific Repo
        delete one or more tags matching <regex>:tag from specifc repo

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_getImage()
{
    cat >&2 << EOF

    $PROGNAME getRemoteImage <imageName> [ <imageName> [ <imageName> [ ... ]]]

        getremoteimage    Get one or more images from some remote, and push to the default repository

    Note: 'getImage' is an alias for 'getRemoteImage'

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_pushImage()
{
    cat >&2 << EOF

    $PROGNAME pushImage [ --fingerprint  ] <imageName> [ <imageName> [ <imageName> [ ... ]]]
    
    push a retained image
       when 'fingerprint' is specified the  associated fingerprint tag (if detected) is pushed

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_rename()
{
    cat >&2 << EOF

    $PROGNAME rename <srcImage> <dstImage>
    
    rename an image
        Rename an image - locally and in $(registry.SERVER)

    examples:
            specify src_image and dst_image
            specify src_image<regex>, srcTag and dstTag on local system
            specify src_image<regex>, srcTag and dstTag in Registry
            specify src_image<regex>, srcTag and dstTag in both Registry and local system

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_report()
{
    cat >&2 << EOF

    $PROGNAME report [ [ <repoName> ] |
                            [ --catalog ] |
                            [ --summary ] | 
                            [ --tags [ <repoName> ] ] | 
                            [ --tag-summary [ <repoName> ] ] | 
                            [ --format <text|json> ] |
                            [ --output <fileName> ]]
              
    Generate a report of contents of the registry
              --catalog     : show the registry catalog (as text)
              --format      : format output as JSON|TEXT
              --output      : name of file to output <filename>
              --keep        : 
              --tags        : show the tags associated with a repository (as text)
              --summary     : 
              --tag-summary : show a summary of tag usage for specified repos

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_retagImages()
{
    cat >&2 << EOF

    $PROGNAME retagImages < newTag> [ <docker-compose.yml> ]

        Retag images defined in docker-compose.yml
    
EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_retagLatest()
{
    cat >&2 << EOF

    $PROGNAME retagLatest [ <srcTag> [<newTag>] ]
    
        retag dev to defined tag (or 'latest' if no tag defined)

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_show()
{
    cat >&2 << EOF

    $PROGNAME show [ --images ] | [ --networks ] | [ --processes ] | [ --services ]

        common 'docker commands' with specific options to make more usefule
              --images      : docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" 
              --networks    : docker networks: also includes ip address and network name
              --processes   : docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}"
              --services    : show services defined in docker-compose.yml

EOF
}

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
function docker-utilities.cmdLineArgs()
{
    local cmd=${1:-}
    shift

    local -A opts=(['cmd']='docker-utilities.usage')
    local longOpts=''
    local shortOpts=''
    local argsCondition

    case "${cmd,,}" in
        help|-h|--help)
            echo "['cmd']='docker-utilities.usage'"
            return 0;;

        -u|--user)
            [[ $# -eq 0 || $1 = -* ]] && trap.die 'invalid arguments!'
            opts['user']="$1"
            shift;;

        -c|--credentials)
            [[ $# -eq 0 || $1 = -* ]] && trap.die 'invalid arguments!'
            opts['credentials']="$1"
            shift;;

        clean)
            opts['cmd']='docker-utilities.clean'
            opts['isrunning']='docker.isRunning'
            opts['message']="clean docker environment by removing old images and stopped containers"
            longOpts=''
            shortOpts=''
            argsCondition='$# -eq 0'
            ;;

        delete)
            opts['action']='registry.deleteImage'
            opts['cmd']='docker-utilities.catalogIterator'
            opts['isrunning']='docker.isRunning'
            opts['message']="delete images in $(registry.SERVER) by specifying regex"
            opts['oper']='docker-utilities.markImageForDeletion'
            longOpts='no_confirm_delete,end:,keepTags,max:,quiet,start:'
            shortOpts='e:km:qs:y'
            argsCondition='$# -ge 0'
            ;;

        deletetag)
            opts['action']='docker-utilities.deleteTagInSpecificRepo'
            opts['cmd']='docker-utilities.catalogIterator'
            opts['isrunning']='docker.isRunning'
            opts['message']="delete specific tag from $(registry.SERVER)"
            opts['oper']='docker-utilities.deleteTag'
            longOpts='quiet'
            shortOpts='aq'
            argsCondition='$# -eq 1'
            ;;

        getimage|getremoteimage)
            opts['cmd']='docker-utilities.getImage'
            opts['isrunning']='docker.isRunning'
            opts['message']="Get one or more images from some remote, and push to $(registry.SERVER)thirdparty"
            longOpts='quiet'
            shortOpts='q'
            argsCondition='$# -eq 1'
            ;;

        pushimage)
            opts['cmd']='docker-utilities.pushImage'
            opts['isrunning']='docker.isRunning'
            opts['message']="push images to $(registry.SERVER)"
            longOpts='fingerprint,quiet'
            shortOpts='fq'
            argsCondition='$# -eq 1'
            ;;

        rename)
            opts['cmd']='docker-utilities.renameImage'
            opts['isrunning']='docker.isRunning'
            opts['message']="rename local images and push them to $(registry.SERVER)"
            longOpts='quiet'
            shortOpts='q'
            argsCondition='$# -eq 2'
            ;;

        report)
            opts['cmd']='docker-utilities.report'
            opts['message']="report remote images in $(registry.SERVER) "
            longOpts='catalog,format:,output:,quiet,summary,tag-summary,tags,keep'
            shortOpts='c:o:qstk'
            argsCondition='$# -ge 0'
            ;;

        retagimages)
            opts['cmd']='docker-utilities.retagImages'
            opts['isrunning']='docker.isRunning'
            opts['message']="retag images defined in docker-compose.yml "
            longOpts=''
            shortOpts=''
            argsCondition='$# -eq 2'
            ;;

        retaglatest)
            opts['cmd']='docker-utilities.retagLatest'
            opts['isrunning']='docker.isRunning'
            opts['message']="retag all 'dev' tagged imagges to 'latest' and push to $(registry.SERVER)"
            longOpts=''
            shortOpts=''
            argsCondition='$# -eq 1 || $# -eq 2'
            ;;

        show)
            opts['cmd']='docker-utilities.show'
            longOpts='images,networks,processes,services'
            shortOpts='inps'
            argsCondition='$# -ge 0'
            ;;

        updateimage|updateremoteimage)
            opts['cmd']='docker-utilities.updateImage'
            opts['isrunning']='docker.isRunning'
            opts['message']="Get one or more images from some remote, push to $(registry.SERVER)thirdparty, and update GIT repo"
            longOpts='quiet'
            shortOpts='q'
            argsCondition='$# -eq 1'
            ;;

        *)
           trap.die "invalid command: $cmd" ;;
    esac


    # Parse command-line options
    longOpts='help,Help,HELP,user:,credentials:,'"$longOpts"
    shortOpts='hHc:u:'"$shortOpts"
    local -r options=$(getopt --longoptions "$longOpts" --options "$shortOpts" --name "$PROGNAME" -- "$@") || docker-utilities.usage '' $?
    eval set -- "$options"

    while true; do    
        case "${1,,}" in
            -h|--h|-help|--help)
                argsCondition='true'
                opts['cmd']='docker-utilities.usage'
                opts['message']=''
                if [ "${opts['cmd']}" = 'docker-utilities.catalogIterator' ]; then
                    opts['oper']="${opts['oper']:17}"
                else
                    opts['oper']="${opts['cmd']:17}"
                fi
                while [ $# -gt 0 ]; do
                    shift
                done
                break;;

            -c)
                if [[ $# -eq 0 || $2 = -* ]]; then
                    opts['oper']='catalog'
                    opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                    argsCondition='$# -eq 0'
                    shift
                else
                    opts['credentials']="$2"
                    shift 2
                fi;;

            -credentials|--credentials)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['credentials']="$2"
                shift 2;;

            -catalog|--catalog)
                argsCondition='$# -eq 0'
                opts['oper']='catalog'
                opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                shift;;

            -e|-end|--end)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['end']="$(jq 'fromdate' '"'$2'"')"
                opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                shift 2;;

            -f)
                if [[ "$longOpts" = *fingerprint* ]]; then
                    opts['fingerprint']=1
                    shift
                else
                    opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['format']="$2"
                    shift 2
                fi;;

            -fingerprint|--fingerprint)
                opts['fingerprint']=1
                shift;;

            -format|--format)
                opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['format']="$2"
                shift 2;;

            -i|-images|--images)
                opts['oper']='images'
                opts['message']="show details about local docker images  aka: <docker images> "
                shift;;

            -k)
                if [[ "$longOpts" = *summary* ]]; then
                    opts['keep']=1
                    shift
                else
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags'
                    opts['keepTags']=1
                    opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images and keepTags"
                fi;;

            -keep|--keep)
                opts['keep']=1
                shift;;

            -keeptags|--keeptags)
                opts['keepTags']=1
                opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images and keepTags"
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags'
                shift;;

            -m|-max|--max)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['max']="$2"
                opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images"
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImages'
                shift 2;;

            -n|-networks|--networks)
                opts['message']='show details about current docker networks'
                opts['oper']='networks'
                shift;;

            -o|-output|--output)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['output']="$2"
                shift 2;;

            -p|-processes|--processes)
                opts['message']="show details about current processes   aka: <docker ps> "
                opts['oper']='processes'
                shift;;

            -q|-quiet|--quiet)
                opts['quiet']=1
                shift;;

            -s)
                if [[ "$longOpts" = *services* ]]; then
                    argsCondition='$# -eq 0'
                    opts['message']="generate a summary report for repos from $(registry.SERVER)"
                    opts['oper']='summary'
                    shift
                else
                    opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['start']="$(jq 'fromdate' '"'$2'"')"
                    shift 2
                fi;;

            -services|--services)
                opts['message']='show services defined in docker-compose.yml'
                opts['oper']='services'
                shift;;

            -start|--start)
                opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['start']="$(jq 'fromdate' '"'$2'"')"
                shift 2;;

            -summary|--summary)
                argsCondition='$# -eq 0'
                opts['message']="generate a summary report for repos from $(registry.SERVER)"
                opts['oper']='summary'
                shift;;

            -t|-tags|--tags)
                argsCondition='$# -eq 1'
                opts['message']="generate a summary report of the tags used by repos from $(registry.SERVER)"
                opts['oper']='tags'
                shift;;

            -tag-summary|--tag-summary)
                argsCondition='$# -eq 1'
                opts['message']="generate a summary report of the tags used by repos from $(registry.SERVER)"
                opts['oper']='tag-summary'
                shift;;

            -u|--user)
                [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['user']="$2"
                shift 2;;

            -y|-no_confirm_delete|--no_confirm_delete)
                opts['do_delete']=1
                shift;;

            --)
                shift
                break;;

            *)
                break;;

        esac
    done

    if [ ${IS_DEBUG:-0} -gt 0 ]; then
        for i in "${!opts[@]}"; do
           printf '%s: %s\n' $i "${opts[$i]}" >&2
        done
        for i in "$@"; do
           printf ' %s\n' "$i" >&2
        done
    fi

    $(eval "[[ $argsCondition ]]") || trap.die 'invalid arguments!'

    appenv.results $(docker-utilities.removeRegistryReference "$@")

    [ -z "${opts['message']:-}" ] || term.elog "${opts['message']} : $*"'\n' 'grey'
    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.addImageToList()
{
    local -r repo=${1:?}
    local -r tags=${2:?}

    if [ -z "${IMAGES_TO_DELETE[$repo]:-}" ]; then
        IMAGES_TO_DELETE[$repo]="$tags"
    else
        IMAGES_TO_DELETE[$repo]+=( "$tags" )
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.catalogIterator()
{
    local fn=${1:?}
    shift

    [ "${OPTS['oper']:-}" ] || trap.die 'Invalid configuration' 
    [ "${OPTS['action']:-}" ] || trap.die 'Invalid configuration'

    local -i status=0
    local -i content=0
    local catalog id name repo tag
    local image name digest repo yesno
    local -a tags repos

    local -a requests=( "$@" )
    [ "${#requests[*]}" -gt 0 ] || requests=( '.+' )


    catalog="$(docker-utilities.filterCatalog "$@")" # ignore errors
    echo >&2

    for name in "${requests[@]}"; do
        if [[ "$name" = *@sha256:* ]]; then
           repo="${name%@*}"
           tag="${name##*@}"

        elif [[ "$name" = *:* ]]; then
            repo="${name%:*}"
            tag="${name##*:}"

        else
            repo="$name"
            tag='^.*$'
        fi

        mapfile -t repos < <(grep -Es '^'"$repo"'$' <<< "$catalog" ||:)
        [ "${#repos[*]}" -gt 0 ] || continue
        (( content++ )) ||:
        for repo in "${repos[@]}"; do
            "$fn" "$repo" "$tag" || status=1
            [ $status -ne 0 ] && break 2
        done
    done
    [ $content -eq 0 ] && trap.die 'No content specified'


    term.elog '\nAbout to delete the following '${#IMAGES_TO_DELETE[*]}' images:      <repo_name>@<digest> : <tags>\n'
    for image in "${!IMAGES_TO_DELETE[@]}"; do
        printf '    %s : %s\n' "$image" "${IMAGES_TO_DELETE[$image]}" | sort >&2
    done
    echo >&2


    if [ "${OPTS['do_delete']:-0}" -eq 0 ]; then
        local prompt='[Yes/No/All/Quit]'
        [ "${#IMAGES_TO_DELETE[*]}" -eq 1 ] && prompt='[Yes/No]'
        for image in "${!IMAGES_TO_DELETE[@]}"; do
            repo="${image%@*}"
            digest="${image##*@}"

            echo -en "Delete $image $prompt ? " >&2
            while true; do
                local yesno='n'
                read yesno
                echo >&2
                yesno="${yesno,,}"
                case "${yesno:0:1}" in
                    q)  return 2;;
                    a)  break 2;;
                    y)  break;;
                    n)  unset IMAGES_TO_DELETE[$image];  break;;
                esac
            done
        done
        echo >&2
    fi
 
    if [ "${#IMAGES_TO_DELETE[*]}" -eq 0 ]; then
        term.elog 'Nothing to delete\n' 'warn'
        return 0
    fi

    for image in "${!IMAGES_TO_DELETE[@]}"; do
        repo="${image%@*}"
	digest="${image##*@}"
        "${OPTS['action']}" "$repo" "$digest" || status=$?
        [ $status -eq 0 ] || break
    done
    return $status
}

#----------------------------------------------------------------------------------------------
#   clean: remove Old Containers and '<none>' images 
function docker-utilities.clean()
{
    docker.clean
    docker-utilities.show 'images' "$@"
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying "max # images"
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImages()
{
    local -r image=${1:?}
    local -r tag=${2:?}
    local json

    local -r name="${image%:*}"
    docker-utilities.digests 'json' "$name"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${name} - does not exist"

    local -i status=0
    local -i max_images="${OPTS['max']:-$MAX_IMAGES}"
    local -ir imageCount=$(jq 'length' <<< "$json")
    if [ $imageCount -ge $max_images ]; then
        local -ir delta=$(( imageCount - $max_images + 1 ))
        [ $delta -le 1 ] || term.log "    repo ${name} contains ${delta} images over recommended limit"'\n' 'lt_yellow'
        json=$(jq -r "sort_by(.createTime|fromdate)[0:${delta}]" <<< "$json")

        local -i idx
        local digest image_json tags
        for (( idx=0; idx < delta; idx++ )); do
            image_json="$(jq '.['$idx']' <<< "$json")"
            digest=$(jq -r '.digest' <<< "$image_json")
            tags=$(jq -r '.tags|join(",")' <<< "$image_json")
            docker-utilities.addImageToList "${name}@$digest" "$tags" || status=1
        done
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying "max # images" + keepTags
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags()
{
    local -r image=${1:?}
    local -r tag=${2:?}
    local json

    local -r name="${image%:*}"
    docker-utilities.digests 'json' "$name"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${name} - does not exist"

    local -i status=0
    local -i max_images="${OPTS['max']:-$MAX_IMAGES}"
    local -ir imageCount=$(jq '[.[]|select((.tags|length) == 1)]|length' <<< "$json")
    if [ $imageCount -ge $max_images ]; then
        local -ir delta=$(( imageCount - max_images + 1 ))
        [ $delta -le 1 ] || term.log "    repo ${name} contains ${delta} images over recommended limit"'\n' 'lt_yellow'
        json=$(jq -r "[.[]|select((.tags|length) == 1)]|sort_by(.createTime|fromdate)[0:${delta}]" <<< "$json")

        local -i idx
        local digest image_json tags
        for (( idx=0; idx < delta; idx++ )); do
            image_json="$(jq '.['$idx']' <<< "$json")"
            digest=$(jq -r '.digest' <<< "$image_json")
            tags=$(jq -r '.tags|join(",")' <<< "$image_json")
            docker-utilities.addImageToList "${name}@$digest" "$tags" || status=1
        done
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying [start] <=|<|>|>= [end]
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime()
{
    local -r image=${1:?}
    local json

    local -r name="${image%:*}"
    docker-utilities.digests 'json' "$name"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${name} - does not exist"

    json=$(jq -r "sort_by(.createTime|fromdate)" <<< "$json")
    local -ir imageCount=$(jq 'length' <<< "$json")

    local -i createTime
    local -i idx
    local digest image_json tags

    local -i status=0
    local -i min_start_time="${opts['start']:-$MIN_START_TIME}"
    local -i max_end_time="${opts['end']:-$MAX_END_TIME}"
    for (( idx=0; idx < imageCount; idx++ )); do
        image_json="$(jq '.['$idx']' <<< "$json")"
        createTime=$(jq -r '.createTime|fromdate' <<< "$image_json")
        [ "$createTime" -gt "$min_start_time" ] && [ "$createTime" -lt "$max_end_time"  ] && continue

        digest=$(jq -r '.digest' <<< "$image_json")
        tags=$(jq -r '.tags|join(",")' <<< "$image_json")
        docker-utilities.addImageToList "${name}@$digest" "$tags" || status=1
    done
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting repos : delete a repo by specifying image:*
function docker-utilities.deleteTagInSpecificRepo()
{
    local -r repo=${1:?}
    local -r digest=${2:?}

    local image json tag
    local -a tags
    local -i pulledImageExists=0

    # get previosuly specified tag
    tag="${TAGS_TO_DELETE[$repo]}"

    # find list of tags that we need to keep
    docker-utilities.digests 'json' "$repo" 'notimes'
    tags=( $(jq -r '.[].tags|join("\n")' <<< "$json"  | grep -v "$tag") )


    if [ "${#tags[*]}" -gt 0 ]; then
        # pull a copy of image so we can restore other tags
        image="$(registry.SERVER)${repo}:$tag"
        local -r localImages=$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$image")
        if [ -z "$localImages" ]; then
            pulledImageExists=1
            docker-utilities.run docker pull "$image"
        fi
    fi

    # remove image from repo
    registry.deleteImage "$repo" "$digest"



    if [ "${#tags[*]}" -gt 0 ]; then

        echo '    restoring tags: '"${tags[*]}" >&2
        echo  >&2

        # push image back using remaining tags
        for tag in "${tags[@]}"; do
            echo "pushing $(registry.SERVER)${repo}:$tag" >&2
            docker-utilities.run docker tag "$image" "$(registry.SERVER)${repo}:$tag"
            docker-utilities.run docker push "$(registry.SERVER)${repo}:$tag"
            docker-utilities.run docker rmi "$(registry.SERVER)${repo}:$tag"
        done

        # remove local copy of image if it wasn't originaly local
        [ "$pulledImageExists" -ne 0 ] || docker-utilities.run docker rmi "$image"
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
# deleting repos : delete a repo by specifying image:*
function docker-utilities.deleteTag()
{
    local -r repo=${1:?}
    local -r tag=${2:?}
    local json tags

    docker-utilities.digests 'json' "$repo" 'notimes'
    json="$( jq -c '.[]|select(.tags|any(test("'$tag'")))' <<< "$json")"

    tags=$(jq -r '.tags|join(",")' <<< "$json")
    if [ "$tags" ]; then
        docker-utilities.addImageToList "${repo}@$(jq -r '.digest' <<< "$json")" "$tags"
        TAGS_TO_DELETE[$repo]="$tag"
    fi
}

#----------------------------------------------------------------------------------------------
# do not call this function from inside a shell when there is an expectation to update REPO_DIGESTS 
function docker-utilities.digests()
{
    local -r var=${1:?}
    local -r repo=${2:?}
    local -r notimes=${3:-}

    if [ -z "${REPO_DIGESTS[$repo]:-}" ]; then
        [ $"${OPTS['quiet']:-0}" -eq 0 ] && term.elog "retrieving digests for $repo"'\n' 'grey'
        REPO_DIGESTS[$repo]="[$(registry.digests "$repo" $notimes)]"
    fi
    read -r "$var" <<< "${REPO_DIGESTS[$repo]}"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.filterCatalog()
{
    local image
    local -a catalog=()
    for image in "$@"; do
        catalog+=( "${image%:*}" )
    done

    [ "${#catalog[*]}" -gt 0 ] || catalog=( '.+' )

    local tmpfile="$(mktemp)"
    printf '%s\n' "${catalog[@]}" > "$tmpfile"

    registry.catalog | grep -E -f "$tmpfile" ||: # ignore errors
    rm "$tmpfile"
    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.getImage()
{
    local -r image=${1:?}

    local -i status=0


    if [ -z "$(docker image ls -q $image)" ]; then
        docker pull "$image" || status=$?
        [ $status -ne 0 ] && return $status
    fi

    docker tag "$image" "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -eq 0 ] && docker push "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -ne 0 ] && return $status

    docker rmi "$image" || status=$?
    docker rmi "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -ne 0 ] && term.elog 'WARNING:  Failed to cleanup temporary images' 'warn'

    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.main()
{
    eval "OPTS=( $1 )"
    readonly OPTS
    shift
 
 
    if [ "${OPTS['isrunning']:-}" ]; then
        "${OPTS['isrunning']}" || trap.die 'Docker is not running'
    fi

    [ "${OPTS['credentials']:-}" ] && __SECRETS_FILE="${OPTS['credentials']}"
    if [ "${OPTS['user']:-}" ]; then
        USERNAME="${OPTS['user']}"
        USER="${OPTS['user']}"

        _REGISTRY_USER="$(registry.USER)"
        _REGISTRY_CREDENTIALS=$(custom.credentials registry)
    fi
 

    if [ ${IS_DEBUG:-0} -ne 0 ]; then
        echo "cmd:    ${OPTS['cmd']}" >&2
        echo "oper:   ${OPTS['oper']}" >&2
        echo "action: ${OPTS['action']}" >&2
    fi

    local status=0
    DEBUG=1
    "${OPTS['cmd']}" ${OPTS['oper']:-} "$@" && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.markImageForDeletion()
{
    local -r repo=${1:?}
    local -r tag=${2:?}

    local digest json
    local -A digests

    docker-utilities.digests 'json' "$repo" 'notimes'
    eval "digests=( $(jq -r '.[]|.tags|=join(",")|"[\(.digest)]=\(.tags)"' <<< "$json") )"
    [ "${#digests[*]}" -le 0 ] && return 0

    for digest in "${!digests[@]}"; do
        grep -Esq '^'"$tag"'$' <<< ${digests[$digest]} && docker-utilities.addImageToList "${repo}@$digest" "${digests[$digest]}"
    done
    return 0
}

#----------------------------------------------------------------------------------------------
# push images to $(registry.SERVER)
function docker-utilities.pushImage()
{
    local -i status=0

    local image
    local -a images=()
    for image in "$@"; do
        [ "${image:-}" ] && images+=( $(registry.SERVER)$image )
    done
    docker.pushRetained ${OPTS['fingerprint']:-} "${images[@]}" && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.removeRegistryReference()
{
    for id in "$@"; do
        [ "${id:-}" ] && echo ${id#$(registry.SERVER)}
    done
}

#----------------------------------------------------------------------------------------------
# rename image : specify src_image and dst_image
function docker-utilities.renameImage()
{
    local src=${1:?}
    local dst=${2:?}
    term.elog "rename local images and push them to $(registry.SERVER) : $*"'\n' 'grey'

    local srcName="${src%:*}"
    local srcTag="${src##*:}"
    [ "${srcName:-}" ] && [ "${srcTag:-}" ] || trap.die "Invalid $src specified"

    local dstName="${dst%:*}"
    local dstTag="${dst##*:}"

    [ "${dstTag:-}" ] || dstTag="$srcTag"
    [ "${dstName:-}" ] && [ "$dstName" != "$dstTag" ] || $dstName="$srcName"
    [ "$srcName" != "$dstName" ] || [ "$srcTag" != "$dstTag" ] || trap.die "$src & $dst specify same image"

    local exists=$(docker image ls --quiet "$(registry.SERVER)$src")
    [ "${exists:-}" ] || docker-utilities.run docker pull "$(registry.SERVER)$src"
    docker-utilities.run docker tag "$(registry.SERVER)$src" "$(registry.SERVER)${dstName}:$dstTag"
    docker.pushRetained 0 "$(registry.SERVER)${dstName}:$dstTag"
    [ "${exists:-}" ] || docker-utilities.run docker rmi "$(registry.SERVER)$src"
    docker-utilities.deleteTag "$srcName" "$srcTag"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.report()
{
    local reportType=${1:-}
    local -i status

    case "${reportType:-}" in
        catalog)
            shift
            registry.catalog && status=$? || status=$?
            ;;

        tags)
            shift
            registry.tags "$@" && status=$? || status=$?
            ;;

        tag-summary)
            shift
            docker-utilities.reportTagSummary "$@" && status=$? || status=$?
            ;;

        *)
            local format="${OPTS['format']:-text}"
            if [ -z "${OPTS['output']:-}" ] && [ "$format" = 'json' ]; then
                docker-utilities.reportCatalogAsJson "$@"  && status=$? || status=$?

            else
                local report_json="/tmp/reportCatalog.$$.json"
                [ "$format" = 'json' ] && report_json="${OPTS['output']}"
                readonly report_json

                {
                    docker-utilities.reportCatalogAsJson "$@" && status=$? || status=$?
                }  > "$report_json"

                if [ $status -eq 0 ] && [ "$format" != 'json' ]; then
            
                    docker-utilities.reportTextFormat "$report_json" && status=$? || status=$?

                    if [ $status -eq 0 ]; then
                        [ "${OPTS['keep']:-0}" -ne 0 ] && return 0
                        for report in summary.txt reportDetails.txt reportList.txt; do
                            report="$(pwd)/$report"
                            case "${OPTS['output']:-}" in
                                *.txt)
                                    cat "$report" > "${OPTS['output']}"
                                    ;;
                                *)
                                    cat "$report"
                                    ;;
                            esac
                            rm "$report"
                        done
                    fi
                    [ ! -e "$report_json" ] || rm "$report_json"
                fi
            fi
        esac
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.reportCatalogAsJson()
{
    local -a catalog
    mapfile -t catalog < <(docker-utilities.filterCatalog "$@") # ignore errors
#ssh ubuntu-s2 df /dev/sdb1 | tail -1 | awk '{print $5 " used, " $3/1024/1024 " GB  available"}' > storage.txt

    if [ "${#catalog[*]}" -eq 0 ]; then
        term.elog '\nNo content specified\n' 'warn'
        exit 1
    fi
    
    echo -n '['
    local -i index=0
    for entry in "${catalog[@]}"; do
        (( index++ )) && echo -n ','

        local digests="$(registry.digests "$entry")"
        printf '{"id":"%05d","repository":"%s"' "$index" "$entry"
        [ -z "$digests" ] || echo -n ',"digests":['"${digests}"']'
        echo -n '}'
    done
    echo -n ']'
    return 0
}


#----------------------------------------------------------------------------------------------
function docker-utilities.reportTagSummary()
{
    local -a catalog
    mapfile -t catalog < <(docker-utilities.filterCatalog "$@") # ignore errors
    if [ "${#catalog[*]}" -gt 0 ]; then
        local -i fingerprints=0
        local -i digests=0
        local -A tags=()
        local json name tag

        for name in "${catalog[@]}"; do
            docker-utilities.digests 'json' "$name" 'notimes'
            [ "${#json}" -gt 0 ] || continue
            (( digests+=$(jq -r '.|length' <<< "$json") )) ||:
            for tag in $(jq -r '.[].tags[]' <<< "$json"); do
                if [ "${#tag}" -eq 64 ]; then
                    (( fingerprints++ )) ||:
                elif [ -z "${tags[$tag]:-}" ]; then
                    tags[$tag]=1
                else
                    (( tags[$tag]++ )) ||:
                fi
            done
        done

        (
            [ "$digests" -gt 0 ] && echo "detected ${digests} image digests"
            [ "$fingerprints" -gt 0 ] && echo "detected ${fingerprints} fingerprints"
            if [ "${#tags[*]}" -gt 0 ]; then
                echo 'detected the following tags'
                for tag in "${!tags[@]}"; do
                    printf '    %s  : %d\n' "$tag"  "${tags[$tag]}"
                done
            fi
        ) >&2
    else
        term.elog '\nNo content specified\n' 'warn'
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.reportTextFormat()
{
    local -r report_json=${1:?}
    local -i status

    docker run --rm \
               --volume "$PROGRAM_DIR":/usr/share/bin \
               --volume "/tmp:/tmp" \
               --volume "$(pwd):/home/groovy/scripts" \
               --user "$(id --user):$(id --group)" \
               -e "JSON=$report_json" \
               --workdir /home/groovy/scripts \
               "$(registry.SERVER)thirdparty/groovy:2.6-jre-alpine" \
               groovy /usr/share/bin/registryReport.groovy \
               && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
# retag images
function docker-utilities.retagImages()
{
    local to=${1:?'"to" tag must be specified'}
    local yaml=${2:-docker-compose.yml}

    [ ! -e "$yaml" ] && trap.die "Unable to locate $yaml"'\n'

    local -a images
    mapfile -f images < <(docker.yamlToJson "$yaml" | jq -r '.services[].image')
    if [ "${#images[*]}" -gt 0 ]; then
        local image target
        for image in "${images[@]}"; do
            image=$(eval echo $image)
            target="${image%:*}:$to"
            docker tag "$image" "$target"
            docker rmi "$image" || :
        done
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.retagLatest()
{
    local from="${1:?}"
    local to="${2:-latest}"

    local image target
    local -a images=()
    while read -r image; do
        target="${image%:*}:$to"
        images+=( "$target" )
        docker tag "$image" "$target"
    done < <(docker images --format '{{.Repository}}:{{.Tag}}' | grep "$from")

    docker.pushRetained '1' "${images[@]}"
    docker rmi "${images[@]}"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.run()
{
    [ $DEBUG -ne 0 ] && (echo -e "${grey}$(printf '%s ' "$@")$reset" >&2)
    eval $@ > /dev/null
}

#----------------------------------------------------------------------------------------------
function docker-utilities.show()
{
    local -r mode=${1:?}
    local filter=${2:-}
    
    local -i status=0
    case "$mode" in
        images)
            # show image report
            local -a images
            echo
            mapfile -t images < <(docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}")
            if [ ${#images[*]} -gt 1 ]; then
                echo -e "\e[97m${images[0]}\e[0m" >&2
                unset images[0]
                if [ "${filter:-}" ]; then
                    [[ $filter == *:* ]] && filter=$(sed -e 's|:|\\s+|' <<< "$filter")                
                    (printf '%s\n' "${images[@]}" | sort | grep -E "$filter") && status=$? || status=$?
                else
                    printf '%s\n' "${images[@]}" | sort && status=$? || status=$?
                fi
                echo
            fi
            ;;

        networks)
            # show networks
            local -a hosts
            local -a networks
            mapfile -t networks < <(docker network ls)
            if [ ${#networks[*]} -gt 1 ]; then
                echo -e "\e[97m${networks[0]}\e[0m" >&2
                unset "networks[0]"
                for network in "${networks[@]}"; do
                    echo $network
                    mapfile -t hosts < <(docker network inspect "$(cut -d ' ' -f 1 <<< "$network")" | \
                                         jq -r ".[].Containers|.[]|[.IPv4Address + \" : \" + .Name]|.[]" | \
                                         sort -t "." -k 4g) && status=$? || status=$?
                    [ "${#hosts[*]}" -gt 0 ] || continue
                    printf '    %s\n' "${hosts[@]}"
                done
            fi
            ;;

        processes)
            # show processes
            local -a containers
            echo
            mapfile -t containers < <(docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}")
            if [ ${#containers[*]} -gt 1 ]; then
                echo -e "\e[97m${containers[0]}\e[0m" >&2
                unset "containers[0]"
                if [ "${filter:-}" ]; then
                    (printf '%s\n' "${containers[@]}" | sort | grep -E "$filter") && status=$? || status=$?
                else
                    printf '%s\n' "${containers[@]}" | sort && status=$? || status=$?
                fi
            fi
            ;;

        services)
            # show docker-compose services
            local yaml=${2:-docker-compose.yml}
            [ ! -e "$yaml" ] && trap.die "Unable to locate $yaml"'\n'

            local jsonConfig=$(docker.yamlToJson "$yaml" | jq -c '.services?')
            [ -z "${jsonConfig:-}" ] && trap.die echo "Invalid file: $yaml"'\n'
            jq -r 'keys[]?' <<< "$jsonConfig" && status=$? || status=$?
            ;;
    esac
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.updateImage()
{
    local image=${1:?}

    local -i status=0
    docker-utilities.getImage "$image" && status=$? || status=$?

    if [ $status -eq 0 ]; then
        local imageName="${image%:*}"
        local version="${image##*:}"
        local name="$(basename "$imageName")"

        if [ -d versions ]; then
            pushd versions  > /dev/null

            # udpate version files
            local file
            for file in $(grep "${name^^}" * | cut -d ':' -f 1); do 
                sed -E -i "s|${name^^}_VERSION=.*$|${name^^}_VERSION=${version}|" $file
            done

            # update GIT repo
            git add -A
            git commit -m "updated ${name^^} to v${version}"
#            git push
            popd > /dev/null
        fi
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.usage()
{
    local -r context="${1:-help}"
    local -ir exit_status="${2:-127}"

    case "$context" in
        clean)
            docker-utilities.helpFor_clean
            ;;
        delete)
            docker-utilities.helpFor_delete
            ;;
        deleteTagInSpecificRepo)
            docker-utilities.helpFor_deleteTagInSpecificRepo
            ;;
        getImage)
            docker-utilities.helpFor_getImage
            ;;
        pushImage)
            docker-utilities.helpFor_pushImage
            ;;
        renameImage)
            docker-utilities.helpFor_rename
            ;;
        report)
            docker-utilities.helpFor_report
            ;;
        retagLatest)
            docker-utilities.helpFor_retagLatest
            ;;
        retagImages)
            docker-utilities.helpFor_retagImages
            ;;
        show)
            docker-utilities.helpFor_show
            ;;
        *)
            docker-utilities.helpFor_general
            ;;
    esac
    exit "$exit_status"
}

#----------------------------------------------------------------------------------------------
#
#      MAIN
#
#----------------------------------------------------------------------------------------------

declare start=$(date '+%s')
declare -r grey='\e[90m'
declare -r white='\e[97m'
declare -r reset='\e[0m'
declare -ir MAX_IMAGES=10
declare -ir MAX_END_TIME=4294967295
declare -ir MIN_START_TIME=0

declare -A OPTS
declare -A IMAGES_TO_DELETE=()
declare -A REPO_DIGESTS=()
declare -A TAGS_TO_DELETE=()

declare -r PROGNAME="$( basename "${BASH_SOURCE[0]}" )"
declare -r PROGRAM_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
declare -i IS_DEBUG=${DEBUG:-0}


declare -r loader="$PROGRAM_DIR/appenv.bashlib"
if [ ! -e "$loader" ]; then
    echo 'Unable to load libraries'
    exit 1
fi
source "$loader"
appenv.loader 'docker-utilities.main'

declare -i status
declare -a args=( $( docker-utilities.cmdLineArgs "$@" ) ) && status=$? || status=$?
[ $status -eq 0 ] && docker-utilities.main "${args[@]}" && status=$? || status=$?
printf '\nElapsed time: %s\n' $(timer.fmtElapsed $(( $(date '+%s') - start )) ) >&2
exit $status
