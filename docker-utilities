#!/bin/bash

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_general()
{
    cat >&2 << EOF

Various operations on the docker subsystem and remote docker registry.

Usage:
    $PROGNAME [ help [ subcommand ]
              | clean
              | delete [ --max <numberOfImages> | --start startTime [ --end endTime ] [ --keepTags ] ] <regex>[:<regex>] <regex>[:<regex>] <regex>[:<regex>] | image@digest
              | deleteLocal [<regex>:]<regex>
              | deleteTag [<regex>:]<regex>
              | digests <repoName>
              | getRemoteImage <imageName> <imageName> <imageName>
              | manifests <imageName>
              | promote <src_tag> <dst_tag> [ <dst_tag> ]
              | pushImage [ --fingerprint  ] <imageName> <imageName> <imageName>
              | rename <srcImageName> <dstImageName>
              | report [[ --catalog ] | [ --summary ] | [ --tags [<repoName>] ] | [ --tag-summary [<repoName>] ] | [ --format <text|json> ] [ --output <fileName> ]]
              | retagImages < newTag> [ <docker-compose.yml> ]
              | retagLatest [ <srcTag> [<newTag>] ]
              | show [ --images ] | [ --networks ] | [ --processes ] | [ --services ]
              | updateImage <imageName> <imageName> <imageName>

Common options:
    -u --user <username>                  Defaults to \${USERNAME:-\$USER}                  
    -c --credentials <credentials_file>   File container key/value pairs for user=pwd
    -q --quiet                            Do not display info about running 'docker' commands or requesting digests
    -y --no_confirm_delete                Confirm action, otherwise do not delete anything

Commands:
    help              Display a basic set of usage instructions
    clean             Clean docker environment by removing old images and stopped containers
    delete            Delete one or more images by specifying <regex>:<regex>
          --keepTags    : delete a range of images in a repo by specifying "max # images" + keepTags
          --max         : delete a range of images in a repo by specifying "max # images"
          --start       : delete a range of images in a repo by specifying [start] <  > [end]
                        : delete images by specifying image@digest
    deleteLocal       Delete local images
    deleteTag         Delete one or more tags
    digests           Display the digests for repo
    getRemoteImage    Get one or more images from some remote, and push to the default repository
    manifests         Display the manifest for an image
    promote           Promote (save) all images with <src_tag> to '$(registry.SERVER)' as <latest> and with their <fingerprint> tag
                        : if <dst_tag> is specified, also save <src_tag> as <dst_tag> in '$(registry.SERVER)'
    pushimage         Push one or more images to '$(registry.SERVER)'
          --fingerprint : also push associated fingerprint if detected
    rename            Rename an image - locally and in '$(registry.SERVER)'
    report            Generate a report of contents of the registry
          --catalog     : show the registry catalog (as text)
          --format      : format output as JSON|TEXT
          --output      : name of file to output <filename>
          --keep        : 
          --tags        : show the tags associated with a repository (as text)
          --summary     : 
          --tag-summary : show a summary of tag usage for specified repos
    retagImages       Retag images defined in docker-compose.yml
    retagLatest       retag dev to defined tag (or 'latest' if no tag defined)
    show              common 'docker commands' with specific options to make more usefule
          --images      : docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" 
          --networks    : docker networks: also includes ip address and network name
          --processes   : docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}"
          --services    : show services defined in docker-compose.yml
    updateRemoteImage 'GetRemoteImage' and update GIT repo

all registry references '$(registry.SERVER)' are automatically stripped from images and/or repos

EOF
    return 1
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_clean()
{
    cat >&2 << EOF

Usage:
    $PROGNAME clean

        remove old images and stopped containers then display a list of existing containers

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_delete()
{
    cat >&2 << EOF

Usage:
    $PROGNAME delete [ --max <numberOfImages>
                     | --start startTime [ --end endTime ] [ --keepTags ] ] <regex>[:<regex>] [ <regex>[:<regex>] [ <regex>[:<regex>] [...]]]
                     | image@digest [ image@digest ] [ image@digest ]
                [ -q|--quiet ] [ -y|--no_confirm_delete ]

        Delete one or more images and/or repos by specifying <regex>:<regex>
              --keepTags    : delete a range of images in a repo by specifying "max # images" + keepTags
              --max         : delete a range of images in a repo by specifying "max # images"
              --start       : delete a range of images in a repo by specifying [start] <  > [end]
                            : delete images by specifying image@digest

    Common options:
        -u --user <username>                  Defaults to \${USERNAME:-\$USER}                  
        -c --credentials <credentials_file>   File container key/value pairs for user=pwd
        -q --quiet              Confirm action, otherwise do not delete anything
        -y --no_confirm_delete  Confirm action, otherwise do not delete anything


    examples:
            delete an image by specifying image@sha256:digest
            delete specific images across multiple repos by specifying <regex>:<regex>
              delete an image by specifying image:tag
              delete a range of images in a repo by specifying image:<regex>
              delete a repo by specifying image
              delete a repo by specifying image:*
              delete multiple repos by specifying <regex>
              delete images in all repos matching *:tag
            delete a range of images in a repo by specifying "max # images"
            delete a range of images in a repo by specifying "max # images" + keepTags
            delete a range of images in a repo by specifying [start]< createTime >[end]

NOTE: a log file is always created when using 'delete'

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_deleteLocal()
{
    cat >&2 << EOF

Usage:
    $PROGNAME deleteLocal <regex>[:<regex>]

    delete local images matching given. (images reamin in $(registry.SERVER))

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_deleteTagInSpecificRepo()
{
    cat >&2 << EOF

Usage:
    $PROGNAME deleteTag <regex>[:<regex>]

    delete Tag In Specific Repo
        delete one or more tags matching <regex>:tag from specifc repo

NOTE: a log file is always created when using 'deleteTag'

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_digests()
{
    cat >&2 << EOF

Usage:
    $PROGNAME digests <repoName>
    
    display the digests and times of all images in a repository

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_getImage()
{
    cat >&2 << EOF

Usage:
    $PROGNAME getRemoteImage <imageName> [ <imageName> [ <imageName> [ ... ]]]

        getremoteimage    Get one or more images from some remote, and push to the default repository

    Note: 'getImage' is an alias for 'getRemoteImage'

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_manifests()
{
    cat >&2 << EOF

Usage:
    $PROGNAME manifests <imageName>
    
    display the manifest for an image

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_promote()
{
    cat >&2 << EOF

Usage:
    $PROGNAME promote <src_tag> <dst_tag> [ <dst_tag> ]

    Promote (save) all images with <src_tag> to '$(registry.SERVER)' as <latest> and with their <fingerprint> tag
                        : if <dst_tag> is specified, also save <src_tag> as <dst_tag> in '$(registry.SERVER)'

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_pushImage()
{
    cat >&2 << EOF

Usage:
    $PROGNAME pushImage [ --fingerprint  ] <imageName> [ <imageName> [ <imageName> [ ... ]]]
    
    push one or more images to $(registry.SERVER)
       when 'fingerprint' is specified the  associated fingerprint tag (if detected) is pushed

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_rename()
{
    cat >&2 << EOF

Usage:
    $PROGNAME rename <srcImage> <dstImage>
    
    rename an image
        Rename an image - locally and in $(registry.SERVER)

    examples:
            specify src_image and dst_image
            specify src_image<regex>, srcTag and dstTag on local system
            specify src_image<regex>, srcTag and dstTag in Registry
            specify src_image<regex>, srcTag and dstTag in both Registry and local system

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_report()
{
    cat >&2 << EOF

Usage:
    $PROGNAME report [ [ <repoName> ] |
                            [ --catalog ] |
                            [ --summary ] | 
                            [ --tags [ <repoName> ] ] | 
                            [ --tag-summary [ <repoName> ] ] | 
                            [ --format <text|json> ] |
                            [ --output <fileName> ]]
              
    Generate a report of contents of the registry
              --catalog     : show the registry catalog (as text)
              --format      : format output as JSON|TEXT
              --output      : name of file to output <filename>
              --keep        : 
              --tags        : show the tags associated with a repository (as text)
              --summary     : 
              --tag-summary : show a summary of tag usage for specified repos

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_retagImages()
{
    cat >&2 << EOF

Usage:
    $PROGNAME retagImages < newTag> [ <docker-compose.yml> ]

        Retag images defined in docker-compose.yml
    
EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_retagLatest()
{
    cat >&2 << EOF

Usage:
    $PROGNAME retagLatest [ <srcTag> [<newTag>] ]
    
        retag dev to defined tag (or 'latest' if no tag defined)

EOF
}

#----------------------------------------------------------------------------------------------
function docker-utilities.helpFor_show()
{
    cat >&2 << EOF

Usage:
    $PROGNAME show [ --images ] | [ --networks ] | [ --processes ] | [ --services ]

        common 'docker commands' with specific options to make more usefule
              --images      : docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" 
              --networks    : docker networks: also includes ip address and network name
              --processes   : docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}"
              --services    : show services defined in docker-compose.yml

EOF
}

#----------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------
function docker-utilities.cmdLineArgs()
{
    local argsCondition longOpts='' options shortOpts=''
    
    local -A opts=()
    [ ${DEBUG:-0} -ne 0 ] && opts['debug']=$DEBUG

    while [ "${1:-}" ]; do
        case "${1,,}" in
            help|-h|--help)
                if [ "${opts['cmd']:-}" ]; then
                    if [ "${opts['cmd']}" = 'docker-utilities.catalogIterator' ]; then
                        opts['oper']="${opts['oper']:17}"
                    else
                        opts['oper']="${opts['cmd']:17}"
                    fi
                    while [ $# -gt 0 ]; do
                        shift
                    done
                else
                    shift
                fi
                opts['cmd']='docker-utilities.usage'
                appenv.results "$@"
                return 0;;

            -c|--credentials)
                [[ $# -le 2 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['credentials']="$2"
                shift 2;;

            --debug)
                opts['debug']=1
                shift;;

            -u|--user)
                [[ $# -le 2 || $2 = -* ]] && trap.die 'invalid arguments!'
                opts['user']="$2"
                shift 2;;

            clean)
                opts['cmd']='docker-utilities.clean'
                opts['isrunning']='docker.isRunning'
                opts['message']="clean docker environment by removing old images and stopped containers"
                opts['log']='activity.log'
                longOpts=''
                shortOpts=''
                argsCondition='$# -eq 0'
                shift;;

            delete)
                opts['action']='docker-utilities.deleteImage'
                opts['cmd']='docker-utilities.catalogIterator'
                opts['isrunning']='docker.isRunning'
                opts['log']='activity.log'
                opts['message']="delete images in $(registry.SERVER) by specifying regex"
                opts['oper']='docker-utilities.markImageForDeletion'
                longOpts='no_confirm_delete,end:,keepTags,max:,quiet,start:'
                shortOpts='e:km:qs:y'
                argsCondition='$# -ge 0'
                shift;;

            deletelocal)
                opts['cmd']='docker-utilities.deleteLocal'
                opts['isrunning']='docker.isRunning'
                opts['log']='activity.log'
                opts['message']="delete images locally by specifying regex"
                argsCondition='$# -gt 0'
                shift;;

            deletetag)
                opts['action']='docker-utilities.deleteTagInSpecificRepo'
                opts['cmd']='docker-utilities.catalogIterator'
                opts['isrunning']='docker.isRunning'
                opts['log']='activity.log'
                opts['message']="delete specific tag from $(registry.SERVER)"
                opts['oper']='docker-utilities.deleteTag'
                longOpts='no_confirm_delete,quiet'
                shortOpts='aqy'
                argsCondition='$# -eq 1'
                shift;;

            digests)
                opts['cmd']='docker-utilities.show_digests'
                opts['isrunning']='docker.isRunning'
                opts['message']="display digests and times for images in $(registry.SERVER)"
                argsCondition='$# -eq 1'
                shift;;

            getimage|getremoteimage)
                opts['cmd']='docker-utilities.getImage'
                opts['isrunning']='docker.isRunning'
                opts['message']="Get one or more images from some remote, and push to $(registry.SERVER)thirdparty"
                longOpts='quiet'
                shortOpts='q'
                argsCondition='$# -eq 1'
                shift;;

            manifests)
                opts['cmd']='docker-utilities.manifests'
                opts['isrunning']='docker.isRunning'
                opts['message']="display manifest of images to $(registry.SERVER)"
                argsCondition='$# -eq 1'
                shift;;

            promote)
                opts['cmd']='docker-utilities.promote'
                opts['isrunning']='docker.isRunning'
                opts['message']="promote to $(registry.SERVER)"
                argsCondition='$# -ge 1'
                shift;;

            pushimage)
                opts['cmd']='docker-utilities.pushImage'
                opts['isrunning']='docker.isRunning'
                opts['message']="push images to $(registry.SERVER)"
                longOpts='fingerprint,quiet'
                shortOpts='fq'
                argsCondition='$# -ge 1'
                shift;;

            rename)
                opts['cmd']='docker-utilities.renameImage'
                opts['isrunning']='docker.isRunning'
                opts['message']="rename local images and push them to $(registry.SERVER)"
                longOpts='quiet'
                shortOpts='q'
                argsCondition='$# -eq 2'
                shift;;

            report)
                opts['cmd']='docker-utilities.report'
                opts['message']="report remote images in $(registry.SERVER) "
                longOpts='catalog,format:,output:,quiet,summary,tag-summary,tags,keep'
                shortOpts='c:o:qstk'
                argsCondition='$# -ge 0'
                shift;;

            retagimages)
                opts['cmd']='docker-utilities.retagImages'
                opts['isrunning']='docker.isRunning'
                opts['message']="retag images defined in docker-compose.yml "
                longOpts=''
                shortOpts=''
                argsCondition='$# -eq 2'
                shift;;

            retaglatest)
                opts['cmd']='docker-utilities.retagLatest'
                opts['isrunning']='docker.isRunning'
                opts['message']="retag all 'dev' tagged imagges to 'latest' and push to $(registry.SERVER)"
                longOpts=''
                shortOpts=''
                argsCondition='$# -eq 1 || $# -eq 2'
                shift;;

            show)
                opts['cmd']='docker-utilities.show'
                longOpts='images,networks,processes,services'
                shortOpts='inps'
                argsCondition='$# -ge 0'
                shift;;

            updateimage|updateremoteimage)
                opts['cmd']='docker-utilities.updateImage'
                opts['isrunning']='docker.isRunning'
                opts['message']="Get one or more images from some remote, push to $(registry.SERVER)thirdparty, and update GIT repo"
                longOpts='quiet'
                shortOpts='q'
                argsCondition='$# -eq 1'
                shift;;

            *)
                break;;
        esac
    done


    [ -z "${opts['cmd']:-}" ] && docker-utilities.helpFor_general


    # Parse command-line options
    if [ "${longOpts:-}" ] && [ "${shortOpts:-}" ]; then
        options=$(getopt --longoptions "$longOpts" --options "$shortOpts" --name "$PROGNAME" -- "$@") || docker-utilities.usage '' $?
        eval set -- "$options"


        while [ "${1:-}" ]; do
            case "${1,,}" in
                -c)
                    if [[ $# -eq 0 || $2 = -* ]]; then
                        opts['oper']='catalog'
                        opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                        argsCondition='$# -eq 0'
                        shift
                    else
                        opts['credentials']="$2"
                        shift 2
                    fi;;

                -catalog|--catalog)
                    argsCondition='$# -eq 0'
                    opts['oper']='catalog'
                    opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                    shift;;

                -e|-end|--end)
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['end']="$(jq --compact-output --monochrome-output 'fromdate' '"'$2'"')"
                    opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                    shift 2;;

                -f)
                    if [[ "$longOpts" = *fingerprint* ]]; then
                        opts['fingerprint']=1
                        shift
                    else
                        opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                        [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                        opts['format']="$2"
                        shift 2
                    fi;;

                -fingerprint|--fingerprint)
                    opts['fingerprint']=1
                    shift;;

                -format|--format)
                    opts['message']="generate a report of the registry catalog from $(registry.SERVER)"
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['format']="$2"
                    shift 2;;

                -i|-images|--images)
                    opts['oper']='images'
                    opts['message']="show details about local docker images  aka: <docker images> "
                    shift;;

                -k)
                    if [[ "$longOpts" = *summary* ]]; then
                        opts['keep']=1
                        shift
                    else
                        opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags'
                        opts['keepTags']=1
                        opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images and keepTags"
                    fi;;

                -keep|--keep)
                    opts['keep']=1
                    shift;;

                -keeptags|--keeptags)
                    opts['keepTags']=1
                    opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images and keepTags"
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags'
                    shift;;

                -m|-max|--max)
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['max']="$2"
                    opts['message']="delete range of images in $(registry.SERVER) by specifying max number of images"
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImages'
                    shift 2;;

                -n|-networks|--networks)
                    opts['message']='show details about current docker networks'
                    opts['oper']='networks'
                    shift;;

                -o|-output|--output)
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['output']="$2"
                    shift 2;;

                -p|-processes|--processes)
                    opts['message']="show details about current processes   aka: <docker ps> "
                    opts['oper']='processes'
                    shift;;

                -q|-quiet|--quiet)
                    opts['quiet']=1
                    shift;;

                -s)
                    if [[ "$longOpts" = *services* ]]; then
                        argsCondition='$# -eq 0'
                        opts['message']="generate a summary report for repos from $(registry.SERVER)"
                        opts['oper']='summary'
                        shift
                    else
                        opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                        opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                        [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                        opts['start']="$(jq --compact-output --monochrome-output 'fromdate' '"'$2'"')"
                        shift 2
                    fi;;

                -services|--services)
                    opts['message']='show services defined in docker-compose.yml'
                    opts['oper']='services'
                    shift;;

                -start|--start)
                    opts['message']="delete range of images in $(registry.SERVER) by specifying start time"
                    opts['oper']='docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime'
                    [[ $# -eq 0 || $2 = -* ]] && trap.die 'invalid arguments!'
                    opts['start']="$(jq --compact-output --monochrome-output 'fromdate' '"'$2'"')"
                    shift 2;;

                -summary|--summary)
                    argsCondition='$# -eq 0'
                    opts['message']="generate a summary report for repos from $(registry.SERVER)"
                    opts['oper']='summary'
                    shift;;

                -t|-tags|--tags)
                    argsCondition='$# -eq 1'
                    opts['message']="generate a summary report of the tags used by repos from $(registry.SERVER)"
                    opts['oper']='tags'
                    shift;;

                -tag-summary|--tag-summary)
                    argsCondition='$# -eq 1'
                    opts['message']="generate a summary report of the tags used by repos from $(registry.SERVER)"
                    opts['oper']='tag-summary'
                    shift;;

                -y|-no_confirm_delete|--no_confirm_delete)
                    opts['do_delete']=1
                    shift;;

                --)
                    shift
                    break;;

                *)
                    break;;

            esac
        done
    fi


    # show args
    if [ ${opts['debug']:-0} -gt 0 ]; then
        {
            for i in "${!opts[@]}"; do
               printf '%s: %s\n' $i "${opts[$i]}"
            done
            echo 'args:'
            for i in "$@"; do
               printf '   %s\n' "$i"
            done
            echo
        } >&2
    fi

    if [ "${argsCondition:-}" ]; then
        eval "[[ $argsCondition ]]" || trap.die 'invalid arguments!'
    fi

    appenv.results $(docker-utilities.removeRegistryReference "$@")

    [ -z "${opts['message']:-}" ] || term.elog "${opts['message']} : $*"'\n' 'grey'
    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.addImageToList()
{
    local -r repo=${1:?}
    shift
    local -ra tags=( $@ )

    if [ -z "${IMAGES_TO_DELETE[$repo]:-}" ]; then
        IMAGES_TO_DELETE[$repo]="${tags[*]}"
    else
        IMAGES_TO_DELETE[$repo]+=" ${tags[*]}"
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.catalogIterator()
{
    local fn=${1:?}
    shift

    [ "${OPTS['oper']:-}" ] || trap.die 'Invalid configuration' 
    [ "${OPTS['action']:-}" ] || trap.die 'Invalid configuration'

    local -i status=0
    local -i content=0
    local catalog digest id ref repo request tag yesno
    local -a tags repos

    local -a requests=( "$@" )
    [ "${#requests[*]}" -gt 0 ] || requests=( '.+' )


    # find the digests coresponding to the images:tags specified
    catalog="$(docker-utilities.filterCatalog "$@")" # ignore errors
    echo >&2
    for request in "${requests[@]}"; do
        repo="$(docker.repo "$request")"
        tag="$(docker.tag "$request")"
        [ -z "${tag:-}" ] && tag='^.*$'

        mapfile -t repos < <(grep -Es '^'"$repo"'$' <<< "$catalog" ||:)
        [ "${#repos[*]}" -gt 0 ] || continue
        (( content++ )) ||:
        for repo in "${repos[@]}"; do
            "$fn" "$repo" "$tag" || status=1
            [ $status -ne 0 ] && break 2
        done
    done
    [ $content -eq 0 ] && trap.die 'No content specified'



    # let user see what is going to be done, then ask for confirmation
    term.elog '\nAbout to delete the following '${#IMAGES_TO_DELETE[*]}' images:      <repo_name>@<digest> : <tags>\n'
    for repo in "${!IMAGES_TO_DELETE[@]}"; do
        mapfile -t tags < <(echo "${IMAGES_TO_DELETE[$repo]}")
        printf '    %s :%s\n' "$repo" "$(printf ' %s' "${tags[@]}" | sort)" | sort >&2
    done
    echo >&2

    if [ "${OPTS['do_delete']:-0}" -eq 0 ]; then
        local prompt='[Yes/No/All/Quit]'
        [ "${#IMAGES_TO_DELETE[*]}" -eq 1 ] && prompt='[Yes/No]'
        for repo in "${!IMAGES_TO_DELETE[@]}"; do

            echo -en "Delete $repo $prompt ? " >&2
            while true; do
                local yesno='n'
                read yesno
                yesno="${yesno,,}"
                case "${yesno:0:1}" in
                    q)  return 2;;
                    a)  break 2;;
                    y)  break;;
                    n)  unset IMAGES_TO_DELETE[$repo];  break;;
                esac
            done
        done
        echo >&2
    fi

    if [ "${#IMAGES_TO_DELETE[*]}" -eq 0 ]; then
        term.elog 'Nothing to delete\n' 'warn'
        return 0
    fi


    if [ ${OPTS['debug']:-0} -gt 0 ]; then
        {
            echo '-----------------------------------------------'
            echo "image to delete:  (image@digest:tags)"
            for ref in "${!IMAGES_TO_DELETE[@]}"; do
                printf '    %s : %s\n' "$ref" "${IMAGES_TO_DELETE[$ref]}"
            done
            echo '-----------------------------------------------'
            echo
        } >&2
    fi


    # iterate through the content, and perform required action
    for ref in "${!IMAGES_TO_DELETE[@]}"; do
        mapfile -t tags < <( echo "${IMAGES_TO_DELETE[$ref]:-}" )
        [ "${#tags[*]}" -gt 0 ] || continue
        "${OPTS['action']}" "$ref" "${tags[@]}" || return $?
     done
    return $status
}

#----------------------------------------------------------------------------------------------
#   clean: remove Old Containers and '<none>' images 
function docker-utilities.clean()
{
    docker.clean
    docker-utilities.show 'images' "$@"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.deleteImage()
{
    local -r ref=${1:?}

    local -r repo="$(docker.repo "$ref")"
    local -r digest="$(docker.tag "$ref")"

    # remove image from repo
    registry.deleteImage "$repo" "$digest"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.deleteLocal()
{
    local ref
    local -a images=()
    for ref in "$@"; do
        images+=( $(docker images -q --filter "reference=${ref}"  --format "{{.Repository}}:{{.Tag}}") )
    done
    if [ ${#images[@]} -eq 0 ]; then
        trap.die "No images matching given criteria: $(IFS=' ' echo $*)"
    else
        docker-utilities.run docker rmi "${images[@]}"
        docker-utilities.show images 
    fi
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying "max # images"
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImages()
{
    local -r image=${1:?}
    local -r tag=${2:?}
    local json

    local -r repo="$(docker.repo "$image")"
    docker-utilities.digests 'json' "$repo"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${repo} - does not exist"

    local -i status=0
    local -i max_images="${OPTS['max']:-$MAX_IMAGES}"
    local -ir imageCount=$(jq --compact-output --monochrome-output 'length' <<< "$json")
    if [ $imageCount -ge $max_images ]; then
        local -ir delta=$(( imageCount - $max_images + 1 ))
        [ $delta -le 1 ] || term.log "    repo ${repo} contains ${delta} images over recommended limit"'\n' 'lt_yellow'
        json=$(jq --compact-output --monochrome-output --raw-output "sort_by(.createTime|fromdate)[0:${delta}]" <<< "$json")

        local -i idx
        local digest image_json tags
        for (( idx=0; idx < delta; idx++ )); do
            image_json="$(jq --compact-output --monochrome-output '.['$idx']' <<< "$json")"
            digest=$(jq --compact-output --monochrome-output --raw-output '.digest' <<< "$image_json")
            tags=$(jq --compact-output --monochrome-output --raw-output '.tags|join(",")' <<< "$image_json")
            docker-utilities.addImageToList "${repo}@$digest" "$tags" || status=1
        done
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying "max # images" + keepTags
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingMaxNumberOfImagesAndKeepTags()
{
    local -r image=${1:?}
    local -r tag=${2:?}
    local json

    local -r repo="$(docker.repo "$image")"
    docker-utilities.digests 'json' "$repo"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${repo} - does not exist"

    local -i status=0
    local -i max_images="${OPTS['max']:-$MAX_IMAGES}"
    local -ir imageCount=$(jq --compact-output --monochrome-output '[.[]|select((.tags|length) == 1)]|length' <<< "$json")
    if [ $imageCount -ge $max_images ]; then
        local -ir delta=$(( imageCount - max_images + 1 ))
        [ $delta -le 1 ] || term.log "    repo ${repo} contains ${delta} images over recommended limit"'\n' 'lt_yellow'
        json=$(jq --compact-output --monochrome-output --raw-output "[.[]|select((.tags|length) == 1)]|sort_by(.createTime|fromdate)[0:${delta}]" <<< "$json")

        local -i idx
        local digest image_json tags
        for (( idx=0; idx < delta; idx++ )); do
            image_json="$(jq --compact-output --monochrome-output '.['$idx']' <<< "$json")"
            digest=$(jq --compact-output --monochrome-output --raw-output '.digest' <<< "$image_json")
            tags=$(jq --compact-output --monochrome-output --raw-output '.tags|join(",")' <<< "$image_json")
            docker-utilities.addImageToList "${repo}@$digest" "$tags" || status=1
        done
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting images within a repo : delete a range of images in a repo by specifying [start] <=|<|>|>= [end]
function docker-utilities.deleteRangeOfImagesInRepoBySpecifyingStartEndTime()
{
    local -r image=${1:?}
    local json

    local -r repo="$(docker.repo "$image")"
    docker-utilities.digests 'json' "$repo"
    [ "${#json}" -gt 0 ] || trap.die "repository: ${repo} - does not exist"

    json=$(jq --compact-output --monochrome-output --raw-output "sort_by(.createTime|fromdate)" <<< "$json")
    local -ir imageCount=$(jq --compact-output --monochrome-output 'length' <<< "$json")

    local -i createTime
    local -i idx
    local digest image_json tags

    local -i status=0
    local -i min_start_time="${opts['start']:-$MIN_START_TIME}"
    local -i max_end_time="${opts['end']:-$MAX_END_TIME}"
    for (( idx=0; idx < imageCount; idx++ )); do
        image_json="$(jq --compact-output --monochrome-output '.['$idx']' <<< "$json")"
        createTime=$(jq --compact-output --monochrome-output --raw-output '.createTime|fromdate' <<< "$image_json")
        [ "$createTime" -gt "$min_start_time" ] && [ "$createTime" -lt "$max_end_time"  ] && continue

        digest=$(jq --compact-output --monochrome-output --raw-output '.digest' <<< "$image_json")
        tags=$(jq --compact-output --monochrome-output --raw-output '.tags|join(",")' <<< "$image_json")
        docker-utilities.addImageToList "${repo}@$digest" "$tags" || status=1
    done
    return $status
}

#----------------------------------------------------------------------------------------------
# deleting repos : delete a repo by specifying image:*
function docker-utilities.deleteTag()
{
    local -r repo=${1:?}
    local -r tag=${2:?}
    local digest json repo_json x
    local -a tagsToDelete
    local -i i

    docker-utilities.digests 'repo_json' "$repo" 'notimes'
    [ "${repo_json:-}" ] || return 0

    for (( i=0; i<$(jq --compact-output --monochrome-output 'length' <<< "$repo_json"); i++ )); do
        json=$(jq --compact-output --monochrome-output '.['$i']' <<< "$repo_json")
        digest=$(jq --compact-output --monochrome-output --raw-output '.digest' <<< "$json")
        [ "${digest:-}" ] || continue

        tagsToDelete=()
        for x in $(jq --compact-output --monochrome-output --raw-output '.tags[]' <<< "$json"); do
            [[ $x =~ $tag ]] || continue
            tagsToDelete+=( "$x" )
        done
        [ "${#tagsToDelete[*]}" -le 0 ] && continue

        docker-utilities.addImageToList "${repo}@$digest" "${tagsToDelete[@]}" || status=1
    done
    return 0
}

#----------------------------------------------------------------------------------------------
# deleting repos : delete a repo by specifying image:*
function docker-utilities.deleteTagInSpecificRepo()
{
    local -r ref=${1:?}
    shift
    local -ra tagsToDelete=( "$@" )
    if [ "${#tagsToDelete[*]}" -eq 0 ]; then
        term.elog "no tags defined for $ref"'\n' 'red'
        return 0
    fi

    local -r repo="$(docker.repo "$ref")"
    loal -r digest="$(docker.tag "$ref")"


    local repo_json
    docker-utilities.digests 'repo_json' "$repo" 'notimes'
    [ "${repo_json:-}" ] || return 0


    local image tag
    local -i noLocalImage=0
    local -a tags

    # get tags associated with same digest, but exclude those we want to delete
    mapfile -t tags < <(jq --compact-output --monochrome-output --raw-output '.[]|select(.digest == "'$digest'").tags[]' <<< "$repo_json" | grep -vF "${tagsToDelete[*]}" ||:)
    {
        echo "ref:       $ref"
        echo "repo:      $repo"
        echo "digest:    $digest"
        echo 'tags to delete:'
        printf '    %s\n' "${tagsToDelete[@]}"
        if [ "${#tags[*]}" -gt 0 ]; then
            echo 'tags to keep:'
            printf '    %s\n' "${tags[@]}"
        fi
        echo
    } >&2

    if [ "${#tags[*]}" -gt 0 ]; then
        # pull a copy of image so we can restore other tags
        image="$(registry.SERVER)${repo}@$digest"
        local -r localImages=$(docker images --format '{{.Repository}}@{{.Digest}}' --filter "reference=$image")
        if [ -z "$localImages" ]; then
            noLocalImage=1
            echo "Downloading ${image} to use to restore tags that are not being deleted." >&2
            docker-utilities.run docker pull "$image"
            
            # cannnot use digesr as reference for 'docker tag', convert to the 'image ID'
            image=$(docker images --format '{{.ID}}' --filter "reference=$image")
            [ ${OPTS['debug']:-0} -gt 0 ] && (echo "image ID:  $image" >&2)
        fi
    fi


    # remove image from repo
    registry.deleteImage "$repo" "$digest"

    if [ "${#tags[*]}" -gt 0 ]; then

        echo 'restoring tags:' >&2
        # push image back using remaining tags
        for tag in "${tags[@]}"; do
            echo "    pushing $(registry.SERVER)${repo}:$tag" >&2
            docker-utilities.run docker tag "$image" "$(registry.SERVER)${repo}:$tag"
            docker-utilities.run docker push "$(registry.SERVER)${repo}:$tag"
        done

        # remove local copy of image if it wasn't originaly local
        if [ "$noLocalImage" -eq 0 ]; then
            # remove local copy of tags  (removing while pushing creates situation where only first tag gets pushed)
            for tag in "${tags[@]}"; do
                docker-utilities.run docker rmi "$(registry.SERVER)${repo}:$tag"
            done
        else
            # remove local copy of image if it wasn't originaly local, as well as all tags
            docker-utilities.run docker rmi -f "$image"
        fi
        echo >&2
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
# do not call this function from inside a shell when there is an expectation to update REPO_DIGESTS 
function docker-utilities.digests()
{
    local -r var=${1:?}
    local -r repo=${2:?}
    local -r notimes=${3:-}

    if [ -z "${REPO_DIGESTS[$repo]:-}" ]; then
        [ "${OPTS['quiet']:-0}" -eq 0 ] && term.elog "retrieving digests for $repo"'\n' 'grey'
        local digests="$(registry.digests "$repo" $notimes)"
        [ -z "${digests:-}" ] && return 0
        REPO_DIGESTS[$repo]="$digests"
    fi
    read -r "$var" <<< "${REPO_DIGESTS[$repo]:-}"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.filterCatalog()
{
    local image
    local -a catalog=()
    for image in "$@"; do
        catalog+=( "$(docker.repo "$image")" )
    done

    [ "${#catalog[*]}" -gt 0 ] || catalog=( '.+' )

    local tmpfile="$(mktemp)"
    printf '%s\n' "${catalog[@]}" > "$tmpfile"

    registry.catalog | grep -E -f "$tmpfile" ||: # ignore errors
    rm "$tmpfile"
    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.getImage()
{
    local -r image=${1:?}

    local -i status=0


    if [ -z "$(docker image ls -q $image)" ]; then
        docker-utilities.run docker pull "$image" || status=$?
        [ $status -ne 0 ] && return $status
    fi

    docker-utilities.run docker tag "$image" "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -eq 0 ] && docker-utilities.run docker push "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -ne 0 ] && return $status

    docker-utilities.run docker rmi "$image" || status=$?
    docker-utilities.run docker rmi "$(registry.SERVER)thirdparty/${image##*/}" || status=$?
    [ $status -ne 0 ] && term.elog 'WARNING:  Failed to cleanup temporary images' 'warn'

    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.main()
{
    # define out 'GLOBALS'
    declare -ir MAX_IMAGES=10
    declare -ir MAX_END_TIME=4294967295
    declare -ir MIN_START_TIME=0

    declare -A OPTS=()
    declare -A IMAGES_TO_DELETE=()
    declare -A REPO_DIGESTS=()


    # extract out options, and handle the common options
    eval "OPTS=( $1 )"
    readonly OPTS
    shift
    [ "${OPTS['cmd']:-}" ] || trap.die 'invalid arguments' 
 
 
    if [ "${OPTS['isrunning']:-}" ]; then
        "${OPTS['isrunning']}" || trap.die 'Docker is not running'
    fi

    [ "${OPTS['credentials']:-}" ] && __SECRETS_FILE="${OPTS['credentials']}"
    if [ "${OPTS['user']:-}" ]; then
        export USERNAME="${OPTS['user']}"
        export USER="${OPTS['user']}"

        export _REGISTRY_USER="${OPTS['user']}"
        export _REGISTRY_CREDENTIALS=$(credentials.get registry)
    fi
    export DEBUG=${OPTS['debug']:-0}
 


    # perform what was asked
    if [ ${OPTS['debug']:-0} -ne 0 ]; then
        echo "cmd:    ${OPTS['cmd']:-}" >&2
        echo "oper:   ${OPTS['oper']:-}" >&2
        echo "action: ${OPTS['action']:-}" >&2
    fi

    local status=0
    if [ -z "${OPTS['log']:-}" ]; then

        # regular output
        "${OPTS['cmd']}" ${OPTS['oper']:-} "$@" && status=$? || status=$?

    else
        # redirect output so we have a filtered version going to log file, and unfiltered version to console (for colors)

        # always create a log file for 
        :>"${OPTS['log']}"
        # create special stdout/stderr (which always receives encoded output)
        exec 3>&1
        (
            # run command & combine stdout + stderr
            # |  split output to fd3 (console copy) & console
            # |  filter out color
            # >>  redirect filtered console to log
            "${OPTS['cmd']}" ${OPTS['oper']:-} "$@" 2>&1 \
              | tee /dev/fd/3 \
              | stdbuf -oL sed -E 's|\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]||g' \
              >> "${OPTS['log']}"
        ) && status=$? || status=$?
        # close special stdout/stderr
        exec 3>&-

    fi
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.manifests()
{
    local -r image="${1:?}"
#    local -ra images=( "$@" )

    echo '"manifest":' >&2

    registry.manifest "$(docker.repo "$image")" "$(docker.tag "$image")" | jq --compact-output --monochrome-output '.'
}

#----------------------------------------------------------------------------------------------
function docker-utilities.markImageForDeletion()
{
    local -r repo=${1:?}
    local -r tag=${2:?}

    local digest json
    local -a digests tags

    docker-utilities.digests 'json' "$repo" 'notimes'
    mapfile -t digests < <(jq --compact-output --monochrome-output --raw-output '.[]|select(.digest == "'$tag'" or (.tags|contains(["'$tag'"])))|.digest' <<< "$json" ||:)
    [ "${#digests[*]}" -le 0 ] && return 0

    for digest in "${digests[@]}"; do
        mapfile -t tags < <(jq --compact-output --monochrome-output --raw-output '.[]|select(.digest == "'$digest'")|.tags[]' <<< "$json" ||:)
        docker-utilities.addImageToList "${repo}@$digest" "${tags[*]}"
    done
    return 0
}

#----------------------------------------------------------------------------------------------
function docker-utilities.promote()
{
    local -r srcTag=${1:?}
    shift
    local -ra dstTags=( "$@" )

    local image newImage tag
    local -i status=0
    local -a images

    mapfile -t images < <(docker images --format '{{.Repository}}:{{.Tag}}' | grep --fixed-strings "$srcTag" ||:)
    if [ ${#images[*]} -le 0 ]; then
        term.elog '\nNo content specified\n' 'warn'
        exit 1
    fi

    # figure out what to push
    local -a toSave=()
    for tag in $(printf '%s\n' 'latest' "${dstTags[@]}" | sort -u); do
        for image in "${images[@]}";do
            newImage="$(docker.baseImage "$image"):$tag"
            docker tag "$image" "$newImage"
            toSave+=( "$newImage" )
        done
    done

    # push the images we created to the registry
    docker.pushRetained 1 "${toSave[@]}" && status=$? || status=$?

    # remove all the images we created
    for image in "${toSave[@]}";do
        term.log "    Removing temporary image: ${image}"'\n' 'lt_blue'
        docker rmi "$image" >/dev/null
    done
    return $status
}

#----------------------------------------------------------------------------------------------
# push images to $(registry.SERVER)
function docker-utilities.pushImage()
{
    local -i status=0

    local image
    local -a images=()
    for image in "$@"; do
        [ "${image:-}" ] && images+=( "$(registry.SERVER)$image" )
    done
    docker.pushRetained ${OPTS['fingerprint']:-0} "${images[@]}" && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.removeRegistryReference()
{
    for id in "$@"; do
        [ "${id:-}" ] && echo ${id#$(registry.SERVER)}
    done
}

#----------------------------------------------------------------------------------------------
# rename image : specify src_image and dst_image
function docker-utilities.renameImage()
{
    local src=${1:?}
    local dst=${2:?}
    term.elog "rename local images and push them to $(registry.SERVER) : $*"'\n' 'grey'

    local srcName="$(docker.repo "$src")"
    local srcTag="$(docker.tag "$src")"
    [ "${srcName:-}" ] && [ "${srcTag:-}" ] || trap.die "Invalid $src specified"

    local dstName="$(docker.repo "$dst")"
    local dstTag="$(docker.tag "$dst")"

    [ "${dstTag:-}" ] || dstTag="$srcTag"
    [ "${dstName:-}" ] && [ "$dstName" != "$dstTag" ] || $dstName="$srcName"
    [ "$srcName" != "$dstName" ] || [ "$srcTag" != "$dstTag" ] || trap.die "$src & $dst specify same image"

    local exists=$(docker image ls --quiet "$(registry.SERVER)$src")
    [ "${exists:-}" ] || docker-utilities.run docker pull "$(registry.SERVER)$src"
    docker-utilities.run docker tag "$(registry.SERVER)$src" "$(registry.SERVER)${dstName}:$dstTag"
    docker.pushRetained 0 "$(registry.SERVER)${dstName}:$dstTag"
    [ "${exists:-}" ] || docker-utilities.run docker rmi "$(registry.SERVER)$src"
    docker-utilities.deleteTag "$srcName" "$srcTag"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.report()
{
    local reportType=${1:-}
    local -i status

    case "${reportType:-}" in
        catalog)
            shift
            registry.catalog && status=$? || status=$?
            ;;

        tags)
            shift
            registry.tags "$@" && status=$? || status=$?
            ;;

        tag-summary)
            shift
            docker-utilities.reportTagSummary "$@" && status=$? || status=$?
            ;;

        *)
            local format="${OPTS['format']:-text}"
            if [ -z "${OPTS['output']:-}" ] && [ "$format" = 'json' ]; then
                docker-utilities.reportCatalogAsJson "$@"  && status=$? || status=$?

            else
                local report_json="/tmp/reportCatalog.$$.json"
                [ "$format" = 'json' ] && report_json="${OPTS['output']}"
                readonly report_json

                {
                    docker-utilities.reportCatalogAsJson "$@" && status=$? || status=$?
                }  > "$report_json"

                if [ $status -eq 0 ] && [ "$format" != 'json' ]; then
            
                    docker-utilities.reportTextFormat "$report_json" && status=$? || status=$?

                    if [ $status -eq 0 ]; then
                        if [ "${OPTS['keep']:-0}" -ne 0 ]; then
                            mv "$report_json" "$(pwd)/reportCatalog.$(date +%Y%m%d%H%M%S).json"
                        else
                            for report in summary.txt reportDetails.txt reportList.txt; do
                                report="$(pwd)/$report"
                                case "${OPTS['output']:-}" in
                                    *.txt)
                                        cat "$report" > "${OPTS['output']}"
                                        ;;
                                    *)
                                        cat "$report"
                                        ;;
                                esac
                                rm "$report"
                            done
                        fi
                    fi
                    [ ! -e "$report_json" ] || rm "$report_json"
                fi
            fi
        esac
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.reportCatalogAsJson()
{
    local -a catalog
    mapfile -t catalog < <(docker-utilities.filterCatalog "$@" ||:) # ignore errors
#ssh ubuntu-s2 df /dev/sdb1 | tail -1 | awk '{print $5 " used, " $3/1024/1024 " GB  available"}' > storage.txt

    if [ "${#catalog[*]}" -eq 0 ]; then
        term.elog '\nNo content specified\n' 'warn'
        exit 1
    fi
    
    echo -n '['
    local -i index=0
    for entry in "${catalog[@]}"; do
        (( index++ )) && echo -n ','

        local digests="$(registry.digests "$entry")"
        printf '{"id":"%05d","repository":"%s"' "$index" "$entry"
        [ -z "$digests" ] || echo -n ',"digests":'"${digests}"
        echo -n '}'
    done
    echo -n ']'
    return 0
}


#----------------------------------------------------------------------------------------------
function docker-utilities.reportTagSummary()
{
    local -a catalog
    mapfile -t catalog < <(docker-utilities.filterCatalog "$@" ||:) # ignore errors
    if [ "${#catalog[*]}" -gt 0 ]; then
        local -i fingerprints=0
        local -i digests=0
        local -A tags=()
        local json name tag

        for name in "${catalog[@]}"; do
            docker-utilities.digests 'json' "$name" 'notimes'
            [ "${#json}" -gt 0 ] || continue
            (( digests+=$(jq --compact-output --monochrome-output --raw-output '.|length' <<< "$json") )) ||:
            for tag in $(jq --compact-output --monochrome-output --raw-output '.[].tags[]' <<< "$json"); do
                if [ "${#tag}" -eq 64 ]; then
                    (( fingerprints++ )) ||:
                elif [ -z "${tags[$tag]:-}" ]; then
                    tags[$tag]=1
                else
                    (( tags[$tag]++ )) ||:
                fi
            done
        done

        (
            [ "$digests" -gt 0 ] && echo "detected ${digests} image digests"
            [ "$fingerprints" -gt 0 ] && echo "detected ${fingerprints} fingerprints"
            if [ "${#tags[*]}" -gt 0 ]; then
                echo 'detected the following tags'
                for tag in "${!tags[@]}"; do
                    printf '    %s  : %d\n' "$tag"  "${tags[$tag]}"
                done
            fi
        ) >&2
    else
        term.elog '\nNo content specified\n' 'warn'
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.reportTextFormat()
{
    local -r report_json=${1:?}
    local -i status

    docker run --rm \
               --volume "$PROGRAM_DIR":/usr/share/bin \
               --volume "/tmp:/tmp" \
               --volume "$(pwd):/home/groovy/scripts" \
               --user "$(id --user):$(id --group)" \
               -e "JSON=$report_json" \
               --workdir /home/groovy/scripts \
               "$(registry.SERVER)thirdparty/groovy:2.6-jre-alpine" \
               groovy /usr/share/bin/registryReport.groovy \
               && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
# retag images
function docker-utilities.retagImages()
{
    local to=${1:?'"to" tag must be specified'}
    local yaml=${2:-docker-compose.yml}

    [ ! -e "$yaml" ] && trap.die "Unable to locate $yaml"'\n'

    local -a images
    mapfile -f images < <(lib.yamlToJson "$yaml" | jq --compact-output --monochrome-output --raw-output '.services[].image' ||:)
    if [ "${#images[*]}" -gt 0 ]; then
        local image target
        for image in "${images[@]}"; do
            image=$(eval echo $image)
            target="$(docker.baseImage "$image"):$to"
            docker-utilities.run docker tag "$image" "$target"
            docker-utilities.run docker rmi "$image" || :
        done
    fi
}

#----------------------------------------------------------------------------------------------
function docker-utilities.retagLatest()
{
    local from="${1:?}"
    local to="${2:-latest}"

    local image target
    local -a images=()
    while read -r image; do
        target="$(docker.baseImage "$image"):$to"
        images+=( "$target" )
        docker-utilities.run docker tag "$image" "$target"
    done < <(docker images --format '{{.Repository}}:{{.Tag}}' | grep "$from")

    docker.pushRetained 1 "${images[@]}"
    docker-utilities.run docker rmi "${images[@]}"
}

#----------------------------------------------------------------------------------------------
function docker-utilities.run()
{
    [ "${OPTS['quiet']:-0}" -eq 0 ] && term.elog "$(printf '%s ' "$@")"'\n' 'grey'
    eval $@ > /dev/null
}

#----------------------------------------------------------------------------------------------
function docker-utilities.show()
{
    local -r mode=${1:?}
    local filter=${2:-}
    
    local -i status=0
    case "$mode" in
        images)
            # show image report
            local -a images
            echo >&2
            mapfile -t images < <(docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" ||:)
            if [ ${#images[*]} -gt 1 ]; then
                echo -e "\e[97m${images[0]}\e[0m" >&2
                unset images[0]
                if [ "${filter:-}" ]; then
                    [[ $filter == *:* ]] && filter=$(sed -e 's|:|\\s+|' <<< "$filter")                
                    (printf '%s\n' "${images[@]}" | sort | grep -E "$filter") && status=$? || status=$?
                else
                    printf '%s\n' "${images[@]}" | sort && status=$? || status=$?
                fi
            fi
            ;;

        networks)
            # show networks
            local -a hosts
            local -a networks
            mapfile -t networks < <(docker network ls ||:)
            if [ ${#networks[*]} -gt 1 ]; then
                echo -e "\e[97m${networks[0]}\e[0m" >&2
                unset "networks[0]"
                for network in "${networks[@]}"; do
                    echo $network 
                    mapfile -t hosts < <(docker network inspect "$(cut -d ' ' -f 1 <<< "$network")" | \
                                         jq --compact-output --monochrome-output --raw-output ".[].Containers|.[]|[.IPv4Address + \" : \" + .Name]|.[]" | \
                                         sort -t "." -k 4g ||:)
                    [ "${#hosts[*]}" -gt 0 ] || continue
                    printf '    %s\n' "${hosts[@]}"
                done
            fi
            ;;

        processes)
            # show processes
            local -a containers
            echo >&2
            mapfile -t containers < <(docker ps --format "table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}\t{{.Ports}}" ||:)
            if [ ${#containers[*]} -gt 1 ]; then
                echo -e "\e[97m${containers[0]}\e[0m" >&2
                unset "containers[0]"
                if [ "${filter:-}" ]; then
                    (printf '%s\n' "${containers[@]}" | sort | grep -E "$filter") && status=$? || status=$?
                else
                    printf '%s\n' "${containers[@]}" | sort && status=$? || status=$?
                fi
            fi
            ;;

        services)
            # show docker-compose services
            local yaml=${2:-docker-compose.yml}
            [ ! -e "$yaml" ] && trap.die "Unable to locate $yaml"'\n'

            local jsonConfig=$(lib.yamlToJson "$yaml" | jq --compact-output --monochrome-output '.services?')
            [ -z "${jsonConfig:-}" ] && trap.die echo "Invalid file: $yaml"'\n'
            jq --compact-output --monochrome-output --raw-output 'keys[]?' <<< "$jsonConfig" && status=$? || status=$?
            ;;
    esac
    echo >&2
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.show_digests()
{
    local -r image="${1:?}"
#    local -ra images=( $@ )


    echo '"digests":' >&2
    {
        registry.digests "$(docker.repo "$image")"
    } | jq --compact-output --monochrome-output '.'
}

#----------------------------------------------------------------------------------------------
function docker-utilities.updateImage()
{
    local image=${1:?}

    local -i status=0
    docker-utilities.getImage "$image" && status=$? || status=$?

    if [ $status -eq 0 ]; then
        local imageName="$(docker.repo "$image")"
        local version="$(docker.tag "$image")"
        local name="$(basename "$imageName")"

        if [ -d versions ]; then
            pushd versions  > /dev/null

            # udpate version files
            local file
            for file in $(grep "${name^^}" * | cut -d ':' -f 1); do 
                sed -E -i "s|${name^^}_VERSION=.*$|${name^^}_VERSION=${version}|" $file
            done

            # update GIT repo
            git add -A
            git commit -m "updated ${name^^} to v${version}"
#            git push
            popd > /dev/null
        fi
    fi
    return $status
}

#----------------------------------------------------------------------------------------------
function docker-utilities.usage()
{
    local -r context="${1:-help}"
    local -ir exit_status="${2:-127}"

    local -A contextHelp=( ['clean']=docker-utilities.helpFor_clean
                           ['delete']=docker-utilities.helpFor_delete
                           ['deletelocal']=docker-utilities.helpFor_deleteLocal
                           ['deletetaginspecificrepo']=docker-utilities.helpFor_deleteTagInSpecificRepo
                           ['digests']=docker-utilities.helpFor_digests
                           ['getimage']=docker-utilities.helpFor_getImage
                           ['getremoteimage']=docker-utilities.helpFor_getImage
                           ['help']=docker-utilities.helpFor_general
                           ['manifests']=docker-utilities.helpFor_manifests
                           ['promote']=docker-utilities.helpFor_promote
                           ['pushimage']=docker-utilities.helpFor_pushImage
                           ['renameimage']=docker-utilities.helpFor_rename
                           ['report']=docker-utilities.helpFor_report
                           ['retaglatest']=docker-utilities.helpFor_retagLatest
                           ['retagimages']=docker-utilities.helpFor_retagImages
                           ['show']=docker-utilities.helpFor_show
                           ['updateImage']=docker-utilities.helpFor_pushImage
                         )

    # show context sensitive help
    ${contextHelp[${context,,}]:-docker-utilities.helpFor_general}
    exit "$exit_status"
}

#----------------------------------------------------------------------------------------------
#
#      MAIN
#
#----------------------------------------------------------------------------------------------

declare -i start=$(date '+%s')
declare -r PROGNAME="$( basename "${BASH_SOURCE[0]}" )"
declare -r PROGRAM_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"


declare -r loader="${PROGRAM_DIR}/appenv.bashlib"
if [ ! -e "$loader" ]; then
    echo 'Unable to load libraries' >&2
    exit 1
fi
source "$loader"
appenv.loader 'docker-utilities.main'


declare -i status=0
declare -a args
args=( $( docker-utilities.cmdLineArgs "$@" ) ) && status=$? || status=$?
[ $status -ne 0 ] || docker-utilities.main "${args[@]:-}" && status=$? || status=$?

declare -i elapsed=$(( $(date '+%s') - start ))
[ $elapsed -gt 1 ] && printf '\nElapsed time: %s\n' $(timer.fmtElapsed $elapsed) >&2

exit $status
