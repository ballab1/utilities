#!/bin/echo 'This script cannot be executabled directly. Please source from another script'

#----------------------------------------------------------------------------------------------
#  functions for 'deploy'
#----------------------------------------------------------------------------------------------
# remove any running containers then delete workspace directory
function deploy.clean()
{
    local network
    # check networks to determine if there are running containers
    local -a networks=( $(lib.yamlToJson "${OPTS['cfgYaml']}" | jq --compact-output --monochrome-output --raw-output '.networks|try .[].name' ||:)
                        "$(basename "${OPTS['workspaceDir']}")_default"
                       )
    for network in "${networks[@]}"; do
        deploy.down "$network" && break
        deploy.down "${network//./}" && break
    done

    # remove workspace folder
    term.log "\$rm -rf ${OPTS['workspaceDir']}"'\n' 'grey'
    sudo rm -rf "${OPTS['workspaceDir']}"
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.cmdLineArgs()
{
    case "${1,,}" in
        -a|--a|--archive)
            OPTS['archive']="$2"
            OPTS['shift']=2
            return 0;;

        -b|--b|--base)
            OPTS['base']="$2"
            OPTS['shift']=2
            return 0;;

        --dev)
            OPTS['dev']=1
            OPTS['shift']=1
            return 0;;

        -l|--l|--latest)
            OPTS['latest']='HEAD'
            OPTS['shift']=1
            return 0;;

        -t|--t|--tag)
            OPTS['container_tag']="$2"
            OPTS['shift']=2
            return 0;;
    esac
    return 1
}

#----------------------------------------------------------------------------------------------
function deploy.configSettingsHelp()
{
    local -r helpdir="${PROGRAM_DIR}/help.${LIB_NAME}"
    local contextHelp="${helpdir}/configSettings.txt"

    # show context sensitive help
    cat "$contextHelp" >&2
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.containerTag()
{
    local -r container_tag=${1:-}

    local branch="$(git.branch)"
    branch="${branch//\//-}"   # replace '/' with '-'
    case "$branch" in
        dev*)                      echo "$branch";;
        master|integration)        echo "${container_tag:-$branch}";;
        *)                         echo 'latest';;
    esac
    return 0
}

#----------------------------------------------------------------------------------------------
# process line from docker-compose which contains 'image:'
function deploy.containerVersion()
{
    local -r line=${1:?}
    local -r service=${2:?}

    local fingerprint newline prefix production promoted

    # capture prefix up to registry
    prefix="$(sed -Ee 's|^(\s+.*'"${OPTS['registry']}"'}).*$|\1|' <<< "$line")"

    newline="${line:${#prefix}}"   # strip prefix from line
    promoted="$newline"
    orgimage="$(unset CONTAINER_TAG; eval "echo $newline")"
    production="$orgimage"
    fingerprint='<none>'

    # only process lines which have 'CONTAINER_TAG'
    if [[ "$newline" = *CONTAINER_TAG* ]]; then
        local container=$(jq --compact-output --monochrome-output --raw-output '.container_name' <<< "$service")
        if [ "${container:-}" ]; then

            # strip :tag'  suffix
            newline="${newline%:*}"
            [[ "$newline" = *CONTAINER_TAG ]] && newline="${newline%:\${CONTAINER_TAG*}"

            # since this service is running, extract the image name from service, and its fingerprint
            orgimage="$(docker inspect "$container" | jq --compact-output --monochrome-output --raw-output '.[].Config.Image')"
            fingerprint=$(docker inspect "$container" | jq --compact-output --monochrome-output --raw-output '.[].Config.Labels."container.fingerprint"')

            # if the fingerprint exists, replace image tag with fingerprint
            [ "$fingerprint" != 'null' ] && newline="${newline}"':${CONTAINER_TAG:-'"${fingerprint}"'}'

            promoted="$(eval echo $newline)"
            production="$(unset CONTAINER_TAG; eval echo $newline)"
        fi
    else
        promoted="$production"
    fi

    # generate our output JSON
    echo -n '{'
    echo -n '"orgline":"'${line}'",'
    echo -n '"newline":"'${prefix}${newline}'",'
    echo -n '"production":"'${prefix}${production}'",'
    echo -n '"promoted":"'${prefix}${promoted}'"'
    echo '}'
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.createVolumeFolders()
{
    local json="${1:?}"
    local service_name="${2:?}"

    local -a dirs=()
    # find 'volumes'; remove container mount (after ':'); exclude any which start with '/' or '~'
    mapfile -t dirs < <(jq --compact-output --monochrome-output --raw-output ".services.${service_name}.volumes[]?" <<< "$json" \
                       | awk -F ':' '{print $1}' \
                       | grep -Ev '^[/~]' \
                       | sort -u ||:)
    [ "${#dirs[*]}" -eq 0 ] && return 0

    local dir
    for dir in "${dirs[@]}"; do
        [ "${dir:0:2}" = './' ] && dir="${dir:2}"                        # remove './' prefix
        # initialize dir when needed. check if there is a coresponding CONFIG file, and strip filename when file exists
        [ -f "${OPTS['cfgDir']}/$dir" ] && dir="$(dirname "$dir")"

        if [ ! -d "${OPTS['workspaceDir']}/$dir" ]; then
            mkdir -p "${OPTS['workspaceDir']}/$dir" ||:
            sudo chown "$EUID" "${OPTS['workspaceDir']}/$dir"
            [ "$dir" = "${service_name}/log" ] && chmod 777 "${OPTS['workspaceDir']}/$dir"
        fi

        # ensure log symlinks are setup
        if [ "$dir" = "${service_name}/log" ] && [ "$(readlink "${OPTS['logDir']}/$service_name")" != "${OPTS['workspaceDir']}/$dir" ]; then
            # get rid of any old stuff that may prevent us creating symlink
            [ -f "${OPTS['logDir']}/$service_name" ] && sudo rm "${OPTS['logDir']}/$service_name"
            [ -h "${OPTS['logDir']}/$service_name" ] && sudo rm "${OPTS['logDir']}/$service_name"
            ln -s "${OPTS['workspaceDir']}/$dir" "${OPTS['logDir']}/$service_name"
        fi
    done
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.docker_compose()
{
    local -i status
    deploy.runInShell docker-compose --file "${OPTS['workspaceYaml']}" "$@" && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
# down containers
function deploy.down()
{
    local network="${1:-}"
    if [ "$network" ]; then
        local -i networkCount=$(docker network ls | grep -cs "$network")
        [ "$networkCount" -gt 0 ] || return 1
    fi

    if [ -f "${OPTS['workspaceYaml']}" ]; then
        term.log 'INFO: bringing down containers to allow "workspace" to be refreshed\n' 'lt_magenta'
        term.log '\nINFO: bringing down containers\n' 'white'
        term.log 'docker-compose --file '"${OPTS['workspaceYaml']}"' down --remove-orphans\n' 'grey'
        deploy.docker_compose down --remove-orphans ||:
    fi

    return 0
}

#----------------------------------------------- EXPORTED FUNCTION: deploy.environmentVar -----
# used by '......setup' files
function deploy.environmentVar()
{
    local -r service=${1:?}
    local -r var=${2:?}
    
    local result="$(lib.yamlToJson "$WORKSPACE_YAML" | jq --compact-output --monochrome-output --raw-output 'try .services.'"$service"'.environment.'"$var" )"
    echo "$(eval echo "$result")" 

    return 0
}
export -f deploy.environmentVar

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called after containers are running so that up-to-date config info is available
function deploy.fixupDCLineAfterRun()
{
    local line="${1:?}"
    local -r service="${2:?}"
    local -r property="${3:?}"       # property for 'jq' to select from JSON:  '.newline' or '.promoted'
    local -r isConfig="${4:-}"

    # don't copy comments to output
    [ -z "${isConfig:-}" ] && grep -Eq '^\s*#' <<< "$line" && return 0

    # update image definition
    if grep -qsE '^\s+image:\s' <<< "$line"; then
        # update workspace/docker-compose.yml when we pull latest images
        line="$(deploy.containerVersion "$line" "$service" | jq --compact-output --monochrome-output --raw-output "$property")"
    fi

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    while read -r keyName; do
        [ -z "${!keyName:-}" ] && trap.die "unrecognized VERSION parameter $keyName used."
        # 'keyName' is 'SOMEMODULE_VERSION',  '!keyName' is the current/new value of 'xxxxxxxxxxxxxxx'
        line="$(sed -E 's|^(\s+.*\$\{'"$keyName"':-)[^\}]+(}.*)$|\1'"${!keyName}"'\2|' <<< "$line")"
    done < <(awk '/([A-Z0-9]+_VERSION):-/ {sub(":.*","");print substr($0,2)}' RS='$' <<< "$line")

    if [ -z "${isConfig:-}" ] && [ "$(grep -cEs ':\?}' <<< "$line")" -gt 0 ]; then
        local indent="$(sed -Ee 's|^(\s+).*$|\1|' <<< "$line")"
        line="${indent}$(eval "echo $line")"
    fi

    echo "$line"
    return 0
}

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called before containers are running so that the workspace 'docker-compose' contains latest user changes
function deploy.fixupDCLineBeforeRun()
{
    local line="${1:?}"
    local -r service="${2:?}"

    # don't copy comments to output
    grep -Eq '^\s*#' <<< "$line" && return 0

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    while read -r keyName; do
        [ -z "${!keyName:-}" ] && continue

        # 'keyName' is 'SOMEMODULE_VERSION',  '!keyName' is the current/new value of 'xxxxxxxxxxxxxxx'
        line="$(sed -E 's|^(\s+.*\$\{'${keyName}':-)[^\}]+(}.*)$|\1'${!keyName}'\2|' <<< "$line")"
    done < <(awk '/([A-Z0-9]+_VERSION):-/ {sub(":.*","");print substr($0,2)}' RS='$' <<< "$line")

    # update default OS with actual OS from container.os file
    local -r os=$(sed -E 's|^\s+.+\$\{OPTS['containerOs']:-([^}]+)}.*$|\1|' <<< "$line")
    if grep -qsE 'OPTS['containerOs']' <<< "$line" && [ "${OPTS['containerOs']}" != "$os" ]; then
        line="$(sed -e 's|'"${os}"'|'"${OPTS['containerOs']}"'|' <<< "$line")"

    # if line has required content [ ex: ${HOST:?} ], then attempt to resolve
    elif [ "$(grep -cEs ':\?}' <<< "$line")" -gt 0 ]; then
        local indent="$(sed -Ee 's|^(\s+).*$|\1|' <<< "$line")"
        line="${indent}$(eval echo $line)"
    fi

    echo "$line"
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.fixWorkspaceYaml()
{
    mkdir -p "${OPTS['workspaceDir']}" ||:
    [ -f "${OPTS['workspaceYaml']}" ] && rm "${OPTS['workspaceYaml']}"
    [ -h "${OPTS['workspaceYaml']}" ] || ln -s "${OPTS['cfgYaml']}" "${OPTS['workspaceYaml']}"
    return 0
}

#----------------------------------------------------------------------------------------------
# parse all BASH tokens/variables from a file
function deploy.getTokens()
{
    local file="${1:?}"

    ########    | *removeUnwantedLines*      | *removeTrailingSpaces, encode_$$,       separateTokens* | *removeUnwantedLines*      | *identifyTokens* | *removeTokenStart,     removeTokenEndings,       setKeyValDelim,          fixUndefinedTokens*,      restore_$$    | sort -u -t '='
    cat "$file" | grep -vE '^((\s*)|(#.*))$' | sed -E -e 's|\s+$||'   -e 's|\$\$|\v|g' -e 's|\$|\n$|g' | grep -vE '^((\s*)|(#.*))$' | grep '\$'        | sed -E -e 's|^\$\{?||' -e 's|"||' -e 's|\}.*$||' -e 's|:-|=|' -e 's|:|=|' -e 's|^([^=]+)=?$|\1=?|' -e 's|\v|$$|g' | sort -u -t '='
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.initGlobals()
{
    # declare & initialize our GLOBAL variables
#export OPTS['cfgEmail'] OPTS['cfgName'] OPTS['cfgUser'] OPTS['cfgDir'] OPTS['cfgYaml'] OPTS['containerOs'] DEBUG_TRACE OPTS['deployYaml']
#export OPTS['hasVersions'] OPTS['hostIp'] OPTS['hostName'] OPTS['logDir'] OPTS['secretsDir'] OPTS['workspaceDir'] OPTS['workspaceYaml'] 
#    declare -r JQ_OPTS='--compact-output --monochrome-output --raw-output'
#    declare -r JQ_OPTS='-c -m -r'



    # set default value for 
    local tag="${OPTS['container_tag']:-}"
    if [ -z "${tag:-}" ] && [ -z "${OPTS['latest']:-}" ]; then
        if [ "${CONTAINER_TAG:-}" ]; then
            tag="$CONTAINER_TAG"
        elif [ "${OPTS['latest']:-}" ]; then
            local default
            [ "${OPTS['latest']}" == 'HEAD' ] && default='latest'
            tag="$(deploy.containerTag "${default:-}")"
        fi
    fi
    [ -z "${tag:-}" ] || OPTS['container_tag']="${tag//\//-}"   # replace '/' with '-'



    [ -e "${OPTS['base']}/.git" ] || trap.die "invalid base directory specified"

    # setup environment
    OPTS['cfgDir']="${OPTS['base']}"

    # verify docker-compose.yml in 'config' dir
    OPTS['cfgYaml']="${OPTS['cfgDir']}/docker-compose.yml"
    [ -e "${OPTS['cfgYaml']}" ] || trap.die "Invalid configuration - no ${OPTS['cfgYaml']}"


    OPTS['deployYaml']="${OPTS['cfgDir']}/deploy.yml"
    [ -e "${OPTS['deployYaml']}" ] || trap.die "Unable to locate deploy configuration file: ${OPTS['deployYaml']}"

    local deploy_json="$(lib.yamlToJson "${OPTS['deployYaml']}")"

    local default_args=$(jq --compact-output --monochrome-output --raw-output 'try .default_args|to_entries' <<< "$deploy_json" ||:)
    if [ "$default_args" ]; then
        local -i idx
        for (( idx=0; idx < $(jq 'length' <<< "$default_args"); idx++ )); do
            local key=$(jq -r ".[$idx].key" <<< "$default_args")
            local val=$(jq -r ".[$idx].value" <<< "$default_args")
            [ "${OPTS[$key]:-}" ] || OPTS[$key]="$val"
        done
    fi


    # verify our basic setup is good
    OPTS['containerOs']="$(jq --compact-output --monochrome-output --raw-output 'try .container_os' <<< "$deploy_json" ||:)"
    [ "${OPTS['containerOs']:-}" ] || trap.die "missing 'OPTS['containerOs']' section in $deploy_json"

    # initialize workspace if required ('docker-compose.yml' is missing)
    OPTS['workspaceDir']="$(deploy.workspace "${OPTS['base']}")"

    mkdir -p "${OPTS['workspaceDir']}" ||:
    OPTS['workspaceYaml']="${OPTS['workspaceDir']}/docker-compose.yml"

    local -a files
    mapfile -t files < <(sudo find "${OPTS['workspaceDir']}" -maxdepth 1 -type f ! -name '*.log' ||:)
    [ "${#files[*]}" -gt 0 ] || deploy.showInitializationBanner


    OPTS['logDir']="${OPTS['base']}/logs"
    OPTS['secretsDir']="${OPTS['workspaceDir']}/.secrets"

#    OPTS['cfgUser']
    : ${OPTS['cfgUser']:=$(git.user)}
    : ${OPTS['cfgUser']:=${USERNAME:-}}
    : ${OPTS['cfgUser']:=${USER:-}}
    OPTS['cfgUser']="${OPTS['cfgUser']%@*}"
    OPTS['cfgName']="${OPTS['cfgName']:-$(git.userName)}"
    OPTS['cfgEmail']="${OPTS['cfgEmail']:-$(git.userEmail)}"
    OPTS['registry']="$(registry.SERVER)"
    environ.container    # HOST_IP : HOST_NAME : HOST_FQDN : CFG_USER_SECRETS : CRYPT_FILE

    local -A deps=()
    local key val
    local -i idx

    # import our setup configuration  (combine 'environment and thirdparty_versions' as they are only separate for readability)
    local json="$(jq --compact-output --monochrome-output '[.environment + .thirdparty_versions|to_entries[]]' <<< "$deploy_json")"
    local -i numkeys=$(jq --compact-output --monochrome-output --raw-output 'length' <<< "$json")

    for (( idx=0; idx<numkeys; idx++ )); do
        key="$(jq --compact-output --monochrome-output --raw-output ".[$idx].key" <<< "$json")"
        val="$(jq --compact-output --monochrome-output --raw-output ".[$idx].value" <<< "$json")"
        if (eval export "$key=$val" 2>/dev/null); then
            eval export "$key=$val"
            readonly "$key"
        else
            deps[$key]="$val"
        fi
    done
    for key in "${!deps[@]}"; do
        val="${deps[$key]}"
        eval export "$key=$val"
        readonly "$key"
    done


    # verify we have the mandatory env variables defined
    [ "${OPTS['cfgUser']:-}" ] || term.elog 'OPTS['cfgUser'] has not been configured.\n' 'yellow'
    [ "${OPTS['cfgName']:-}" ] || term.elog 'OPTS['cfgName'] has not been configured.\n'  'yellow'
    [ "${OPTS['cfgEmail']:-}" ] || term.elog 'OPTS['cfgEmail'] has not been configured.\n' 'yellow'
    [[ "${OPTS['cfgUser']:-}" && "${OPTS['cfgName']:-}" && "${OPTS['cfgEmail']:-}" ]] || deploy.configSettingsHelp
    [[ -z "${HOST_IP:-}" || "${HOST_IP}" = *\ * ]] && trap.die 'HOST_IP is invalid or has not been configured. Please update the '\''environment'\'' section in deploy.yml'
    [ "${HOST_NAME:-}" ] || term.elog 'HOST_NAME has not been configured. Please update the '\''environment'\'' section in deploy.yml\n'
    [[ "${OPTS['cfgUser']:-}" && "${OPTS['cfgName']:-}" && "${OPTS['cfgEmail']:-}" && "${HOST_IP:-}" && "${HOST_NAME:-}" ]] || trap.die 'Invalid configuration'
    [[ "${OPTS['cfgUser']:-}" != root ]] || trap.die 'Deploy of packages as root user is not permitted\n'

    OPTS['hasVersions']="$(jq --compact-output --monochrome-output --raw-output 'has("versions")' <<< "$deploy_json" ||:)"


    # verify that all our environment variables have been set
    deploy.verifyEnvironmentForFile docker-compose.yml

    # enable container logging during startup
    : ${DEBUG_TRACE:=0}
    DEBUG_TRACE=$(( ++DEBUG_TRACE )) ||:

    # ensure our log dir exists
    [ -d "${OPTS['logDir']}" ] || mkdir -p "${OPTS['logDir']}" ||:

    if [ "$(jq --compact-output --monochrome-output --raw-output 'has("skip_wait")' <<< "$deploy_json")" = 'true' ]; then
        mapfile -t SKIP_WAIT < <(jq --compact-output --monochrome-output --raw-output '.skip_wait[]' <<< "$deploy_json" ||:)
    else
        SKIP_WAIT=()
    fi

    # verify our basic setup is good
    mapfile -t COMPLETION_MSG < <(jq --compact-output --monochrome-output --raw-output 'try .completion_msg[]' <<< "$deploy_json" ||:)
    readonly COMPLETION_MSG


    # fix up any default arg references
    if [ "$default_args" ]; then
        for (( idx=0; idx < $(jq 'length' <<< "$default_args"); idx++ )); do
            local key=$(jq -r ".[$idx].key" <<< "$default_args")
            eval local val=$(jq -r ".[$idx].value" <<< "$default_args")
            grep '\$' <<< "${OPTS[$key]:-}" && [ "${val:-}" != "${OPTS[$key]:-}" ] && OPTS[$key]="$val"
        done
    fi

    if [ "${OPTS['hasVersions']:-false}" = 'true' ]; then
        WORKSPACE_DIR="${OPTS['workspaceDir']}"
        versions.data "${OPTS['deployYaml']}" "${OPTS['latest']:-}"
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.initialize()
{
    return 0
}

#----------------------------------------------------------------------------------------------
# setup workspace if it does not exist
function deploy.initializeWorkspace()
{
    # run in subshell to isolate exports
    local json="$(lib.yamlToJson "${OPTS['workspaceYaml']}")"
    [ $? -ne 0 ] && trap.die "Failed to parse ${OPTS['workspaceYaml']}"
    local -ri num_secrets=$(jq --compact-output --monochrome-output '.services[]|select(has("secrets"))|.secrets[]' <<< "$json" | wc -l)
    [ "$num_secrets" -eq 0 ] || deploy.populateSecrets


    # create the folders which are mounted by containers (defined in docker-compose volumes)
    local -A service_tasks=()
    for service_name in $(jq --compact-output --monochrome-output --raw-output '.services|keys[]?' <<< "$json"); do

        # look for individual service tasks (to run later)
        local initFunction="${OPTS['cfgDir']}/${service_name}.setup"
        [ -e  "$initFunction" ] && service_tasks["$service_name"]="$initFunction"

        # get any defined volumes
        deploy.createVolumeFolders "$json" "$service_name"
    done

    local -i stat
    local -i status=0
    for task in $(printf '%s\n' "${!service_tasks[@]}" | sort); do
        chmod a+rx "${service_tasks[$task]}"
        "${service_tasks[$task]}" && stat=$? || stat=$?
        [ "$stat" ] || status=1
    done

    # update secret references (cannot apply these with other docker-compose.yml updates)
    [ "$num_secrets" -eq 0 ] || deploy.updateSecretRefs "${OPTS['cfgYaml']}"

    # run any startup
    if [ -e "${CONFIG_DIR}/deploy.setup" ]; then
        "${CONFIG_DIR}/deploy.setup" && stat=$? || stat=$?
        [ "$stat" ] || status=1
    fi
    [ "$status" ] || trap.die "initialization errors detected"

    return "$status"
}

#----------------------------------------------------------------------------------------------
function deploy.initWorkspace()
{
    #  restart devops_container_environment  (performs configuration if needed)
    term.log '$deploy.restart\n' 'grey'
    deploy.restart "${OPTS['latest']:-}"
}

#----------------------------------------------- EXPORTED FUNCTION: deploy.isValidService -----
function deploy.isValidService()
{
    local -r service=${1:?}
    
    local result="$(lib.yamlToJson "${WORKSPACE_DIR}/docker-compose.yml" | jq --compact-output --monochrome-output --raw-output 'try .services|has("'"$service"'")' )"

    [ "${result:-}" != 'true' ] && return 1
    return 0
}
export -f deploy.isValidService

#----------------------------------------------- EXPORTED FUNCTION: deploy.passwordSecret -----
# used by '......setup' files
function deploy.passwordSecret()
{
    local -r service=${1:?}
    local -r pwdVar=${2:?}

    local secret jqQuery
    local -r json="$(lib.yamlToJson "${WORKSPACE_DIR}/docker-compose.yml")"
    local password="$(jq --compact-output --monochrome-output --raw-output '.services.'${service}'.environment.'${pwdVar} <<< "$json" )"
    if [ "$password" = 'null' ];then
        password="$(jq --compact-output --monochrome-output --raw-output '.services.'${service}'.environment.'${pwdVar}'_FILE' <<< "$json" )"
        secret="$(basename "$password")"
        jqQuery='.secrets."'"${secret}"'".file'
        local pwd_file="$(eval echo "$(jq --compact-output --monochrome-output --raw-output "$jqQuery" <<< "$json" )")"
        [ "$pwd_file" = 'null' ] && trap.die "Undefined password file in '${WORKSPACE_DIR}/docker-compose.yml'.  Used by startup of service: $service"
        [ -e "$pwd_file" ] || trap.die "Password file: '$pwd_file' not found. Used by startup of service: $service"
        password=$(< "$pwd_file")
    fi
    echo "$password"
    return 0
}
export -f deploy.passwordSecret

#----------------------------------------------------------------------------------------------
function deploy.populateSecrets()
{
    if [ -d "${OPTS['secretsDir']}" ]; then
        # OPTS['secretsDir'] already exists. no need to populate
        :

    elif [ -z "${CFG_USER_SECRETS:-}" ]; then
        [ "${OPEN_SECRETS_REPO:-}" ] || trap.die  "no definition provided for 'secrets'"
        term.log 'populating '"${OPTS['secretsDir']}"' with user defined secrets\n'
        mkdir -p "$(dirname "${OPTS['secretsDir']}")"
        git.clone "$OPEN_SECRETS_REPO" "${OPTS['secretsDir']}"

    elif [ -d "$CFG_USER_SECRETS" ] && [ "$(readlink -f "$CFG_USER_SECRETS")" != "$(readlink -f "${OPTS['secretsDir']}")" ]; then
        term.log 'populating '"${OPTS['secretsDir']}"' from local secrets dir\n'
        mkdir -p "${OPTS['secretsDir']}"
        cp -r "$CFG_USER_SECRETS"/* "${OPTS['secretsDir']}"/

    elif git.lsRemote "$CFG_USER_SECRETS" &> /dev/null ; then
        term.log 'populating '"${OPTS['secretsDir']}"' from git secrets\n'
        mkdir -p "$(dirname "${OPTS['secretsDir']}")"
        git.clone "$CFG_USER_SECRETS" "${OPTS['secretsDir']}" --quiet
        if [ -f "${OPTS['secretsDir']}/.gitattributes" ] && [ "$(grep -cs 'git-crypt' "${OPTS['secretsDir']}/.gitattributes")" -gt 0 ]; then
            [ -e "${CRYPT_FILE:-}" ] || trap.die "secrets are encoded, but CRYPT_FILE: '${CRYPT_FILE:-}' does not exist"
            (cd "${OPTS['secretsDir']}" ||: ; git.cryptUnlock )
        fi

    else
        trap.die  "missing 'secrets' directory in OPTS['workspaceDir']"
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.pushImages()
{
    local -r dc_yaml=${1:?}

    local -a images=()
    local -r json=$(lib.yamlToJson "$dc_yaml")

    # extract images from docker-compose
    
    local image
    while read -r image; do
        images+=( "$(eval "echo $image")" )
    done < <(jq --compact-output --monochrome-output --raw-output '.services[].image' <<< "$json")

    docker.pushRetained 1 "${images[@]}"
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.refreshContainers()
{
    # make sure we start the correct versions
    if [ "${OPTS['dev']:-}" ]; then
        return 0
    elif [ "${OPTS['latest']:-}" = 'HEAD' ]; then
        term.log '\nINFO: updating containers to latest versions\n' 'white'
    else
        term.log '\n'"INFO: using container fingerprints defined in docker-compose.yml"'\n' 'white'
    fi
    term.log 'docker-compose --file '"${OPTS['workspaceYaml']}"' pull\n' 'grey'
    deploy.docker_compose pull || return 1
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.removeCBFlogs()
{
    while read -r dir; do
        [ -f "${dir}/cbf.log" ] || continue
        sudo rm "${dir}/cbf.log"
    done < <(find "${OPTS['workspaceDir']}" -mindepth 2 -maxdepth 2 -type d -name log)
    return 0
}

#------------------------------------------- EXPORTED FUNCTION: deploy.replaceIpAddresses -----
function deploy.replaceIpAddresses()
{
    local -r filename=${1:?}
    local -r HOST_IP=${2:?}

    if [ -e "$filename" ]; then
        local expr='s|${HOST_IP}|'"${HOST_IP}"'|g'
        sudo sed -i -e "$expr" "$filename"
    fi
    return 0
}
export -f deploy.replaceIpAddresses

#----------------------------------------------------------------------------------------------
#  restart devops_container_environment  (performs configuration if needed)
function deploy.restart()
{
    local latest="${1:-${OPTS['latest']:-}}"

    term.log '$deploy.restart\n' 'grey'
    term.elog "CONTAINER_TAG: ${OPTS['container_tag']:-<using default>}\n"

    cd "${OPTS['workspaceDir']}" ||:

    deploy.runInShell deploy.initializeWorkspace
    deploy.removeCBFlogs


    # restart our environment
    deploy.restartContainers "$latest" || exit 1

    local -r run_log="${OPTS['workspaceDir']}/run.log"
    deploy.waitForInitializationComplete "${OPTS['workspaceYaml']}" "$run_log"

    term.log '\nINFO: removing old containers\n' 'white'
    docker.clean

    docker.showProcessReport
    echo

    # show help at end of deploy
    [ "${INITIALIZE_COMPLETE:-}" ] && term.log 'Initializing complete.\n' 'white'
    if [ "${#COMPLETION_MSG[*]}" -gt 0 ]; then
        local msg
        for msg in "${COMPLETION_MSG[@]}"; do
            term.log "$(eval "echo $msg")"'\n' 'white'
        done
    fi
    exit 0
}

#----------------------------------------------------------------------------------------------
function deploy.restartContainers()
{
    local -r latest=${1:-}
    local -i status

    # stop any running containers
    term.log '\nINFO: bringing down containers\n' 'white'
    term.log 'docker-compose --file '"${OPTS['workspaceYaml']}"' down\n' 'grey'
    deploy.docker_compose down --remove-orphans ||:

    set -o verbose
    sudo find -L "${OPTS['logDir']}" -type f ! -name '.*' -delete
    set +o verbose

    deploy.refreshContainers && status=$? || status=$?
    [ $status -eq 0 ] || return $status

    term.log '\nINFO: bringing up containers\n' 'white'
    term.log 'docker-compose --file '"${OPTS['workspaceYaml']}"' up --detach\n' 'grey'
    # docker-compose v1.17.0 does not like '--detach'!
    deploy.docker_compose up -d  && status=$? || status=$?
    if [ $status -ne 0 ]; then
        term.log 'Failed to succussfully deploy container services.\n' 'white'
        exit 1
    fi

    # fixup docker-compose.yml to reflect the image versions in use
    if [ "${latest:-}" = 'HEAD' ]; then
        echo
        # Updating reference docker-compose.yml
        deploy.updateDockerCompose 'updateCfgYaml'
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.restoreImages()
{
    if [ "${OPTS['archive']:-}" ]; then
        term.elog 'unpacking docker images from archive '"${OPTS['archive']}"'\n' 'white'
        term.log 'docker load --input '"${OPTS['archive']}"'\n' 'grey'
        docker load --input "${OPTS['archive']}"
    else
        term.elog 'no archive file specified\n'
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.runInShell()
{
    [ $# -eq 0 ] && return 0
    local -a args=( "$@" )

    local -i status
    # execute in subshell so as to isolate exported variables
    (
        [[ -z "${CFG_USER:-}" && "${OPTS['cfgUser']:-}" ]] && CFG_USER="${OPTS['cfgUser']}"
        export CFG_USER
        [[ -z "${CFG_NAME:-}" && "${OPTS['cfgName']:-}" ]] && CFG_NAME="${OPTS['cfgName']}"
        export CFG_NAME
        [[ -z "${CFG_EMAIL:-}" && "${OPTS['cfgEmail']:-}" ]] && CFG_EMAIL="${OPTS['cfgEmail']}"
        export CFG_EMAIL
        [[ -z "${CONFIG_DIR:-}" && "${OPTS['cfgDir']:-}" ]] && CONFIG_DIR="${OPTS['cfgDir']}"
        export CONFIG_DIR
        [[ -z "${CONTAINER_OS:-}" && "${OPTS['containerOs']:-}" ]] && CONTAINER_OS="${OPTS['containerOs']}"
        export CONTAINER_OS
        [[ -z "${CONTAINER_TAG:-}" && "${OPTS['container_tag']:-}" ]] && CONTAINER_TAG="${OPTS['container_tag']}"
        export CONTAINER_TAG
        [[ -z "${HOST_IP:-}" && "${OPTS['hostIp']:-}" ]] && HOST_IP="${OPTS['hostIp']}"
        export HOST_IP
        [[ -z "${SECRETS_DIR:-}" && "${OPTS['secretsDir']:-}" ]] && SECRETS_DIR="${OPTS['secretsDir']}"
        export SECRETS_DIR
        [[ -z "${WORKSPACE_DIR:-}" && "${OPTS['workspaceDir']:-}" ]] && WORKSPACE_DIR="${OPTS['workspaceDir']}"
        export WORKSPACE_DIR
        export WORKSPACE_YAML

        "${args[@]}"

    ) && status=$? || status=$?
    return $status
}

#----------------------------------------------------------------------------------------------
function deploy.saveImages()
{
    local -a images=()
    while read -r image;do
        images+=( $(eval echo $image) )
    done < <(lib.yamlToJson "${OPTS['cfgDir']}/docker-compose.yml" | jq --compact-output --monochrome-output --raw-output '.services[].image')

    local -r filename="${OPTS[archive]:-$(git.describe --tags --always --dirty).tar}"
    term.log 'docker save --output '"${filename} $(echo ${images[*]})"'\n' 'grey'
    docker save --output "$filename" "${images[@]}"
    [ -f "$filename" ] && gzip -fv "$filename"
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.showInitializationBanner()
{
    term.log '******************************************************************************\n' 'white'
    term.log '*                                                                            *\n' 'white'
    term.log "*  initializing DevOps Container Environment on $(environ.ipAddress)"'\n'         'white'
    term.log '*                                                                            *\n' 'white'
    term.log '******************************************************************************\n' 'white'
    export INITIALIZE_COMPLETE='true'
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.updateDockerCompose()
{
    local -r mode=${1:?}

    local dst_yaml json process src_yaml
    local -a args=()

    # setup the conditions to control how docker.compose gets updated
    case "$mode" in
        updateCfgYaml)
            src_yaml="${OPTS['cfgYaml']}"
            dst_yaml="${OPTS['cfgYaml']}"
            process='deploy.fixupDCLineAfterRun'
            json=$(lib.yamlToJson "$dst_yaml")
            args=( '.newline' 'isConfig' )
            ;;

        promote)
            src_yaml="${OPTS['cfgYaml']}"
            dst_yaml="${OPTS['cfgYaml']}"
            process='deploy.fixupDCLineAfterRun'
            json=$(lib.yamlToJson "$dst_yaml")
            args=( '.promoted' 'isConfig' )
            ;;

        production)
            src_yaml="${OPTS['cfgYaml']}"
            dst_yaml="${OPTS['cfgDir']}/docker-compose.master.yml"
            process='deploy.fixupDCLineAfterRun'
            json=$(lib.yamlToJson "${OPTS['workspaceYaml']}")
            args=( '.production' 'isConfig' )
            ;;

        *)
            trap.die "Invalid option passed to 'function ${FUNCNAME[0]}()'"
            ;;
    esac


    local -i status
    local -a services="$(lib.yamlToJson "$src_yaml" | jq --compact-output --monochrome-output --raw-output '.services|keys[]')"
    local tmp_file="${dst_yaml#.*}.tmp"
    (
        local service='null'
        local key=''
        while read -r line; do

            # skip blank lines
            if [ -z "${line:-}" ] || grep -sq '^\s+$' <<< "$line" ; then
                echo
                continue
            fi

            # look for 'service' definition  (capture start of line, to [:#], then look for key)
            key="$(sed -E -e 's|^(.+?[:#])\s.*$|\1|' <<< "$line" | sed -E -e 's|^\s+(\w+):\s*$|\1|')"
            if [ "${key:-}" ] && [ "${json:-}" ]; then

                # find service that defines image
                grep -qE '^\s+'"${key}"':\s*$' <<< "$line" && \
                    grep -q "$key" <<< "$services" && \
                    service=$(jq --compact-output --monochrome-output ".services.$key" <<< "$json")
            fi

            # process line
            if ! "$process" "$line" "$service" "${args[@]:-}"; then
                term.elog "Failed to process $line"'\n' 'warn'
                break
            fi
        done < "$src_yaml"
    ) > "$tmp_file"
    [ $? -ne 0 ] && trap.die "Failed to process file: $dst_yaml"

    lib.updateFile "$tmp_file" "$src_yaml"
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.updateSecretRefs()
{
    local -r dc_yaml=${1:?}
    local tmp_file="${dc_yaml}.tmp"
    sed -r -e 's|file:\s+~/|file: '"$(readlink -f ~)"'/|' "$dc_yaml" > "$tmp_file"

    lib.updateFile "$tmp_file" "$dc_yaml"
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.validateDockerComposeYaml()
{
    local -r dc_yaml=${1:?}
    local ports=$(jq --compact-output --monochrome-output '.services[].ports[]' <<< "$dc_yaml")
    [ $(echo $ports | sort | wc -l) -eq $(echo $ports | sort -u) ] || return 1
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.verifyEnvironmentForFile()
{
    local -r file=${1:?}

    local var
    local -a unknown=()
    local -a tokens=()

    # scan file for BASH tokens of form: ${TOKEN} or ${TOKEN:-default} or ${TOKEN:?}
    while read -r var; do
        # ignore tokens which have a default value
        if [ $(grep -c '?' <<< "$var") -ne 0 ]; then
            var="${var%%=*}"                             # extract token
            [ "${var:-}" ] || continue                   # ignore if null

            for v in CFG_USER CFG_NAME CFG_EMAIL CONFIG_DIR CONTAINER_OS CONTAINER_TAG WORKSPACE_DIR; do
                [ "$var" = "$v" ] && continue 2
            done

            if [ -z "${!var:-}" ]; then
                unknown+=( "$var" )    # add to 'unknown' unless TOKEN exists in our ENV
                continue
            fi
            var="${var}='${!var}'"
        fi
        tokens+=( "$var" )
    done < <(deploy.getTokens "$file" | grep -Ev 'CONTAINER_TAG|DEV_TEAM' | sort -u ||: )

    if [ ${#unknown[*]} -gt 0 ]; then
        trap.die 'The following environment variables are undefined:'$(printf '\n    %s' "${unknown[@]}")
    fi

    local org_file="${OPTS['workspaceDir']}/.env"
    local tmp_file="${OPTS['workspaceDir']}/.env.tmp"
    printf '%s\n' "${tokens[@]}" > "$tmp_file"
    lib.updateFile "$tmp_file" "$org_file"
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.waitForInitializationComplete()
{
    local -r dc_yaml=${1:?}
    local -r run_log=${2:?}

    # get the list of containers we will be checking
    local -a containers
    mapfile -t containers < <(lib.yamlToJson "$dc_yaml" | jq --compact-output --monochrome-output --raw-output '.services|map(.container_name)|sort[]')

    # initialize the log
    echo "Started at: ${START_TIME}" > "$run_log"

    local -A finished=( )
    local -a lines=()
    local container line
    local -i index=1

    term.log '\n'"INFO: waiting for ${#containers[*]} containers to complete their startup"'\n' 'white'

    # check for containers that we skip
    for container in "${containers[@]}"; do
        [ "${container,,}" ] || continue                               # ignore invalid container
        [ "${finished[${container,,}]:-}" ] && continue                # ignore if we already have this result


        # ignore any that are not built with CBF (since they will not contain string we look for)
        local isCBFcontainer="$(docker inspect "${container,,}" | jq --compact-output --monochrome-output '.[].Config.Labels|has("container.git.url") and has("version.cbf")')"
        if [ "$isCBFcontainer" != 'true' ];then
            printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
            finished[$container]='0'
            SKIP_WAIT+=( "$container" )
            continue
        fi

        # ignore any that are defined in 'SKIP_WAIT'
        if [ "${#SKIP_WAIT[*]}" -gt 0 ] && [ $(printf '%s\n' "${SKIP_WAIT[@]}" | grep -cs "$container") -gt 0 ]; then
            printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
            finished[$container]='0'
            continue
        fi
    done

    while [ "${#finished[*]}" -lt "${#containers[*]}" ]; do
        # sleep 5 secs between scans
        sleep 5
        lines=()

        # check all known containers
        for container in "${containers[@]}"; do
            [ "${container,,}" ] || continue                               # ignore invalid container
            [ "${finished[${container,,}]:-}" ] && continue                # ignore if we already have this result

            # look for specific 'end of startup' string in logs
            local text="$(docker logs "${container,,}" 2>&1 | grep -s 'Finished executing startup' | head -1 ||: )"
            [ "$text" ] || continue                                        # ignore blank lines

            # keep track of what has finished
            lines+=( "$(sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$text" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }')_${container,,}" )
            [ "$(docker logs "${container,,}" 2>&1 | grep -sc '>>>>> issue while executing ' ||: )" -gt 0 ] && text='\e[93m'"$text"'\e[0m'
            finished[${container,,}]="$text"
        done

        # print out any containers we found in this scan
        [ "${#lines[*]}" -gt 0 ] || continue
        for line in $(printf '%s\n' "${lines[@]}" | sort -t '_' -k 1n,2); do   # sort by time taken to finish startup
            container="${line##*_}"                                            # extract container name
            container="${container,,}"
            printf '%02d. %b\n' $(( index++ )) "${finished[${container}]:-}"
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        done
    done


    # update the run.log from each 'docker logs'
    for container in "${containers[@]}"; do
       # if [ "${#SKIP_WAIT[*]}" -gt 0 ] && [ $(printf '%s\n' "${SKIP_WAIT[@]}" | grep -cs "$container") -gt 0 ]; then
          {
            echo 
            echo '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
            echo "${container}"
            echo
            docker logs "${container}" 2>&1                      # grab the log
          } >> "$run_log"
       # fi
    done
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.waitForInitializationComplete_2()
{
    local -r dc_yaml=${1:?}
    local -r run_log=${2:?}

    # get the list of containers we will be checking
    local -a containers
    mapfile -t containers < <(lib.yamlToJson "$dc_yaml" | jq --compact-output --monochrome-output --raw-output '.services|map(.container_name)|sort[]')

    # initialize the log
    echo "Started at: ${START_TIME}" > "$run_log"

    local container line
    local -i index=1
    local -a lines=()
    local -A finished=( )


    cbf_container() {
        # look for specific 'end of startup' string in logs
        docker logs "${1,,}" 2>&1 | grep -s 'Finished executing startup' | head -1 ||:
    }
    x_container() {
        printf '%02d. %s: skipping wait.\n' $(( index++ )) "${1^^}"
    }

    cbf_error() {
        docker logs "${container,,}" 2>&1 | grep -sc '>>>>> issue while executing ' ||:
    }
    x_error() {
        printf '%02d. %s: skipping wait.\n' $(( index++ )) "${1^^}"
    }

    cbf_text() {
        sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$2" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }'
    }
    x_text() {
        :
    }


    term.log '\n'"INFO: waiting for ${#containers[*]} containers to complete their startup"'\n' 'white'

    # check for containers that we skip
    for container in "${containers[@]}"; do
        [ "${container,,}" ] || continue                               # ignore invalid container
        [ "${finished[${container,,}]:-}" ] && continue                # ignore if we already have this result


        # ignore any that are not built with CBF (since they will not contain string we look for)
        local isCBFcontainer="$(docker inspect "${container,,}" | jq --compact-output --monochrome-output '.[].Config.Labels|has("container.git.url") and has("version.cbf")')"
        if [ "$isCBFcontainer" != 'true' ];then
            printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
            finished[$container]='0'
            SKIP_WAIT+=( "$container" )
            continue
        fi

        # ignore any that are defined in 'SKIP_WAIT'
        if [ "${#SKIP_WAIT[*]}" -gt 0 ] && [ $(printf '%s\n' "${SKIP_WAIT[@]}" | grep -cs "$container") -gt 0 ]; then
            printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
            finished[$container]='0'
            continue
        fi
    done

    while [ "${#finished[*]}" -lt "${#containers[*]}" ]; do
        # sleep 5 secs between scans
        sleep 5
        lines=()

        # check all known containers
        for container in "${containers[@]}"; do
            [ "${container,,}" ] || continue                               # ignore invalid container
            [ "${finished[${container,,}]:-}" ] && continue                # ignore if we already have this result

            # look for specific 'end of startup' string in logs
            local text="$(docker logs "${container,,}" 2>&1 | grep -s 'Finished executing startup' | head -1 ||: )"
            [ "$text" ] || continue                                        # ignore blank lines

            # keep track of what has finished
            lines+=( "$(sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$text" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }')_${container,,}" )
            [ "$(docker logs "${container,,}" 2>&1 | grep -sc '>>>>> issue while executing ' ||: )" -gt 0 ] && text='\e[93m'"$text"'\e[0m'
            finished[${container,,}]="$text"
        done

        # print out any containers we found in this scan
        [ "${#lines[*]}" -gt 0 ] || continue
        for line in $(printf '%s\n' "${lines[@]}" | sort -t '_' -k 1n,2); do   # sort by time taken to finish startup
            container="${line##*_}"                                            # extract container name
            container="${container,,}"
            printf '%02d. %b\n' $(( index++ )) "${finished[${container}]:-}"
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        done
    done


    # update the run.log from each 'docker logs'
    for container in "${containers[@]}"; do
       # if [ "${#SKIP_WAIT[*]}" -gt 0 ] && [ $(printf '%s\n' "${SKIP_WAIT[@]}" | grep -cs "$container") -gt 0 ]; then
          {
            echo 
            echo '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
            echo "${container}"
            echo
            docker logs "${container}" 2>&1                      # grab the log
          } >> "$run_log"
       # fi
    done
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.workspace()
{
    local -r base_dir=${1:?}
    echo "${base_dir}/workspace.$(basename "$base_dir")"
    return 0
}

#---------------------------------------------------------------------------------------------- 
